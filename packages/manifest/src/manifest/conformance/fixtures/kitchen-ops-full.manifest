entity PrepTask {
  property required id: string
  property required tenantId: string
  property required name: string
  property required status: string = "open"
  property claimedBy: string = ""
  property claimedAt: number = 0
  property required stationId: string = ""
  property required priority: number = 3
  property required quantityTotal: number = 0
  property quantityCompleted: number = 0
  property required eventId: string = ""

  // Computed properties
  computed isClaimed: boolean = self.claimedBy != ""
  computed isCompleted: boolean = self.status == "done"
  computed percentComplete: number = self.quantityTotal > 0 ? (self.quantityCompleted / self.quantityTotal) * 100 : 0

  // Constraints
  constraint validStatus: self.status in ["open", "in_progress", "done", "canceled"]
  constraint positiveQuantity: self.quantityTotal >= 0 "Total quantity must be non-negative"
  constraint validPriority: self.priority >= 1 and self.priority <= 10 "Priority must be 1-10"

  // Guard constraints (WARN)
  guard taskOpen: self.status == "open" warn "Task is not open"
  guard claimedByUser: self.claimedBy == context.user.id warn "Task is claimed by another user"
  guard notCompleted: self.status != "done" warn "Task is already completed"

  // Block constraints (BLOCK)
  guard taskNotOpen:block self.status == "open" "Task is not open - cannot claim"
  guard stationNotAtCapacity:block self.status == "open" "Station is at capacity - cannot claim"

  command claim(stationId: string) {
    guard self.status == "open"
    guard stationCapacity: context.station.capacity > 0 {
      message: "Station {stationName} has capacity for {currentTasks}/{maxCapacity} tasks"
      details: {
        stationName: context.station.name
        currentTasks: context.station.currentTasks
        maxCapacity: context.station.capacity
      }
    }
    guard claimedByUser: self.claimedBy == context.user.id or self.claimedBy == "" {
      severity: warn
      message: "Task is claimed by {otherUser}"
      details: {
        otherUser: self.claimedBy
      }
    }

    mutate status = "in_progress"
    mutate claimedBy = context.user.id
    mutate claimedAt = now()
    mutate stationId = stationId

    emit PrepTaskClaimed
  }

  command start() {
    guard self.status == "in_progress"
    guard claimedByUser: self.claimedBy == context.user.id "Only the claimer can start"

    mutate status = "in_progress"
    emit PrepTaskStarted
  }

  command complete(quantity: number) {
    guard self.status == "in_progress"
    guard claimedByUser: self.claimedBy == context.user.id "Only the claimer can complete"
    guard positiveQuantity: quantity >= 0 {
      severity: warn
      message: "Completing with quantity {quantity} - less than total {total}"
      details: {
        quantity: quantity
        total: self.quantityTotal
      }
    }

    mutate quantityCompleted = quantity
    mutate status = "done"

    emit PrepTaskCompleted
  }

  command release(reason: string) {
    guard self.status == "in_progress"
    guard claimedByUser: self.claimedBy == context.user.id "Only the claimer can release"

    mutate status = "open"
    mutate claimedBy = ""
    mutate claimedAt = 0
    mutate stationId = ""

    emit PrepTaskReleased
  }

  command cancel(reason: string) {
    guard self.status != "done" {
      severity: warn
      message: "Cancelling task {taskName} with {pct}% complete"
      details: {
        taskName: self.name
        pct: self.percentComplete
      }
    }
    guard self.status != "canceled" "Task is already canceled"

    mutate status = "canceled"
    emit PrepTaskCanceled
  }
}

entity Station {
  property required id: string
  property required tenantId: string
  property required name: string
  property required capacity: number = 1
  property required currentTasks: number = 0
  property isActive: boolean = true

  computed isAtCapacity: boolean = self.currentTasks >= self.capacity
  computed capacityRemaining: number = max(0, self.capacity - self.currentTasks)
  computed availablePercentage: number = (self.capacityRemaining / self.capacity) * 100

  constraint positiveCapacity: self.capacity > 0
  constraint validTasks: self.currentTasks >= 0

  command assignTask(taskId: string) {
    guard stationActive: self.isActive "Station is not active"
    guard stationCapacity: self.currentTasks < self.capacity {
      severity: warn
      message: "Station at {pct}% capacity"
      details: {
        pct: self.availablePercentage
      }
    }
    guard notFull:block self.currentTasks < self.capacity "Station is at capacity"

    mutate currentTasks = self.currentTasks + 1

    emit StationTaskAssigned
  }

  command removeTask(taskId: string) {
    guard hasTasks: self.currentTasks > 0 "No tasks to remove"
    guard self.currentTasks > 0 {
      severity: warn
      message: "Removing task from station"
    }

    mutate currentTasks = self.currentTasks - 1

    emit StationTaskRemoved
  }
}

entity InventoryItem {
  property required id: string
  property required tenantId: string
  property required name: string
  property required quantityOnHand: number = 0
  property required quantityReserved: number = 0
  property required parLevel: number = 0
  property required costPerUnit: number = 0
  property required locationId: string = ""
  property isActive: boolean = true

  computed quantityAvailable: number = self.quantityOnHand - self.quantityReserved
  computed isBelowPar: boolean = self.quantityOnHand < self.parLevel
  computed stockoutRisk: string = self.quantityAvailable <= 0 ? "out_of_stock" : self.quantityAvailable < self.parLevel * 0.5 ? "low" : "normal"

  constraint positiveQuantities: self.quantityOnHand >= 0 and self.quantityReserved >= 0
  constraint reserveDoesNotExceedOnHand: self.quantityReserved <= self.quantityOnHand "Cannot reserve more than available"

  // Warn constraints
  guard belowPar:warn self.quantityOnHand < self.parLevel {
    message: "Item {name} is below par level"
    details: {
      name: self.name
      current: self.quantityOnHand
      par: self.parLevel
    }
  }

  // Block constraints
  guard noStockout:block self.quantityReserved + input.quantity <= self.quantityOnHand {
    message: "Cannot reserve {requested} - only {available} available"
    details: {
      requested: input.quantity
      available: self.quantityAvailable
    }
  }

  command reserve(quantity: number, eventId: string) {
    guard self.quantityAvailable >= quantity {
      severity: warn
      message: "Low stock warning: {available} remaining"
      details: {
        available: self.quantityAvailable
      }
    }
    guard noStockout:block self.quantityAvailable >= quantity {
      message: "Insufficient stock for reservation"
      details: {
        requested: quantity
        available: self.quantityAvailable
      }
    }

    mutate quantityReserved = self.quantityReserved + quantity

    emit InventoryReserved
  }

  command consume(quantity: number, lotId: string) {
    guard self.quantityOnHand >= quantity {
      severity: warn
      message: "Consuming {quantity} units"
      details: {
        quantity: quantity
        onHand: self.quantityOnHand
      }
    }
    guard enoughStock:block self.quantityOnHand >= quantity "Insufficient stock"

    mutate quantityOnHand = self.quantityOnHand - quantity
    mutate quantityReserved = self.quantityReserved - quantity

    emit InventoryConsumed
  }

  command restock(quantity: number, costPerUnit: number) {
    guard positiveQuantity: quantity > 0 {
      severity: warn
      message: "Restocking {quantity} units at {cost} per unit"
      details: {
        quantity: quantity
        cost: costPerUnit
        totalCost: quantity * costPerUnit
      }
    }

    mutate quantityOnHand = self.quantityOnHand + quantity
    mutate costPerUnit = costPerUnit

    emit InventoryRestocked
  }
}

store PrepTask in memory
store Station in memory
store InventoryItem in memory

event PrepTaskClaimed: "kitchen.task.claimed" {
  taskId: string
  claimedBy: string
  stationId: string
  timestamp: number
}

event PrepTaskStarted: "kitchen.task.started" {
  taskId: string
  startedBy: string
  timestamp: number
}

event PrepTaskCompleted: "kitchen.task.completed" {
  taskId: string
  completedBy: string
  quantity: number
  timestamp: number
}

event PrepTaskReleased: "kitchen.task.released" {
  taskId: string
  releasedBy: string
  reason: string
  timestamp: number
}

event PrepTaskCanceled: "kitchen.task.canceled" {
  taskId: string
  canceledBy: string
  reason: string
  timestamp: number
}

event StationTaskAssigned: "kitchen.station.task.assigned" {
  stationId: string
  taskId: string
  timestamp: number
}

event StationTaskRemoved: "kitchen.station.task.removed" {
  stationId: string
  taskId: string
  timestamp: number
}

event InventoryReserved: "kitchen.inventory.reserved" {
  itemId: string
  quantity: number
  eventId: string
  timestamp: number
}

event InventoryConsumed: "kitchen.inventory.consumed" {
  itemId: string
  quantity: number
  lotId: string
  timestamp: number
}

event InventoryRestocked: "kitchen.inventory.restocked" {
  itemId: string
  quantity: number
  costPerUnit: number
  timestamp: number
}

// Policies for override authorization
policy KitchenStaffCanClaim override:
  user.role in ["kitchen_staff", "line_cook", "sous_chef", "head_chef", "manager", "admin"]
  "Kitchen staff and managers can claim prep tasks"

policy KitchenStaffCanComplete override:
  user.role in ["kitchen_staff", "line_cook", "sous_chef", "head_chef", "manager", "admin"]
  "Kitchen staff and managers can complete prep tasks"

policy ManagersCanOverride block:
  user.role in ["manager", "admin"]
  "Only managers and admins can override blocking constraints"

policy InventoryStaffCanReserve override:
  user.role in ["kitchen_staff", "line_cook", "sous_chef", "head_chef", "manager", "admin", "inventory_staff"]
  "Kitchen and inventory staff can reserve items"

policy ManagersCanRestock override:
  user.role in ["manager", "admin"]
  "Only managers can restock inventory"
