// Test: Station capacity constraints

entity Station {
  property required id: string
  property required tenantId: string
  property required name: string
  property required capacity: number = 1
  property required currentTasks: number = 0
  property isActive: boolean = true

  computed isAtCapacity: boolean = self.currentTasks >= self.capacity
  computed capacityRemaining: number = max(0, self.capacity - self.currentTasks)
  computed availablePercentage: number = self.capacity > 0 ? (self.capacityRemaining / self.capacity) * 100 : 0

  constraint positiveCapacity: self.capacity > 0 "Capacity must be positive"
  constraint validTasks: self.currentTasks >= 0 "Task count cannot be negative"

  command assignTask(taskId: string) {
    constraint nearCapacity:warn self.currentTasks >= self.capacity * 0.8 "Station nearing capacity"
    constraint notFull:block self.currentTasks < self.capacity "Station is at capacity"
    guard self.isActive "Station is not active"

    mutate currentTasks = self.currentTasks + 1

    emit StationTaskAssigned
  }

  command removeTask(taskId: string) {
    guard self.currentTasks > 0 "No tasks to remove"

    mutate currentTasks = self.currentTasks - 1

    emit StationTaskRemoved
  }

  command updateCapacity(newCapacity: number) {
    guard newCapacity > 0 "Capacity must be positive"
    guard newCapacity >= self.currentTasks "New capacity cannot be less than current tasks"

    mutate capacity = newCapacity

    emit StationCapacityUpdated
  }
}

store Station in memory

event StationTaskAssigned: "kitchen.station.task.assigned" {
  stationId: string
  taskId: string
  timestamp: number
}

event StationTaskRemoved: "kitchen.station.task.removed" {
  stationId: string
  taskId: string
  timestamp: number
}

event StationCapacityUpdated: "kitchen.station.capacity.updated" {
  stationId: string
  newCapacity: number
  timestamp: number
}
