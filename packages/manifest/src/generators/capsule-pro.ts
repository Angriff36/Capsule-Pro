/**
 * Capsule-Pro Projection Generator
 *
 * This generator emits Next.js App Router route handlers for Manifest entities.
 * It's an application-specific projection for Capsule-Pro that:
 * - Uses existing PrismaStore adapters (no new store code)
 * - Uses existing auth/context helpers (no new auth code)
 * - Uses existing response utilities (no new response types)
 *
 * @see .specify/memory/CAPSULE_PRO_MANIFEST_PROJECTION.md for contract
 */

import type { IR } from "../manifest/ir";

const VERSION = "0.1.0";

/**
 * Route operation types supported by the generator
 */
export interface RouteOperation {
  method: "GET" | "POST" | "PUT" | "DELETE";
  path: string;
  operation: "list" | "get" | "create" | "update" | "delete" | "command";
}

/**
 * Generator options
 */
export interface CapsuleProGeneratorOptions {
  /** Entity name to generate routes for */
  entityName: string;
  /** Operations to generate */
  operations: RouteOperation[];
  /** Source manifest file path (for provenance) */
  sourceManifest?: string;
}

/**
 * Generate Next.js App Router route handler code
 *
 * @param ir - Manifest intermediate representation
 * @param options - Generator options
 * @returns Generated route handler code
 */
export function generateCapsuleProRouteHandler(
  ir: IR,
  options: CapsuleProGeneratorOptions
): string {
  const { entityName, operations, sourceManifest } = options;

  // Find the entity in IR
  const entity = ir.entities.find((e) => e.name === entityName);

  if (!entity) {
    throw new Error(`Entity "${entityName}" not found in IR`);
  }

  const lines: string[] = [];
  const generatedAt = new Date().toISOString();

  // ===== Generated Header =====
  lines.push("// @generated");
  lines.push(`// Generated by Capsule-Pro Manifest Generator v${VERSION}`);
  lines.push("// DO NOT EDIT - Changes will be overwritten");
  if (sourceManifest) {
    lines.push(`// Source manifest: ${sourceManifest}`);
  }
  lines.push("// Generator: packages/manifest/src/generators/capsule-pro.ts");
  lines.push("//");
  lines.push(
    "// Escape hatch: Create a manual route in a sibling directory and import"
  );
  lines.push("// the generated handler as a helper function.");
  lines.push("//");
  lines.push("// Provenance:");
  lines.push(`//   Generated At: ${generatedAt}`);
  lines.push("");

  // ===== Imports =====
  // Check if any operation needs runtime (mutations)
  const needsRuntime = operations.some(
    (op) => !["list", "get"].includes(op.operation)
  );

  lines.push('import { auth } from "@repo/auth/server";');
  lines.push('import { database } from "@repo/database";');

  if (needsRuntime) {
    lines.push("import {");
    lines.push(`  create${entityName}Runtime,`);
    lines.push("  type KitchenOpsContext,");
    lines.push('} from "@repo/kitchen-ops";');
  }

  lines.push("import {");
  lines.push("  manifestErrorResponse,");
  lines.push("  manifestSuccessResponse,");
  lines.push('} from "@repo/kitchen-ops/route-helpers";');
  lines.push('import { getTenantIdForOrg } from "@/app/lib/tenant";');

  if (needsRuntime) {
    lines.push(
      'import { createPrismaStoreProvider } from "@repo/kitchen-ops/prisma-store";'
    );
  }

  lines.push("");

  // ===== Handler Comments =====
  lines.push("/**");
  lines.push(` * Generated route handler for ${entityName}`);
  lines.push(" *");
  if (sourceManifest) {
    lines.push(` * Generated from: ${sourceManifest}`);
  }
  lines.push(" *");
  lines.push(" * This handler uses the Manifest runtime for:");
  lines.push(" * - Entity creation with constraint validation");
  lines.push(" * - Command execution with guard checking");
  lines.push(" * - Automatic persistence through PrismaStore");
  lines.push(" */");
  lines.push("");

  // ===== Route Handler Methods =====
  for (const op of operations) {
    lines.push(generateRouteHandlerMethod(entityName, op));
    lines.push("");
  }

  return lines.join("\n");
}

/**
 * Generate a single route handler method (GET, POST, etc.)
 */
function generateRouteHandlerMethod(
  entityName: string,
  operation: RouteOperation
): string {
  const lines: string[] = [];

  lines.push(`export async function ${operation.method}(request: Request) {`);
  lines.push("  // 1. Auth check");
  lines.push("  const { orgId } = await auth();");
  lines.push("  if (!orgId) {");
  lines.push(
    '    return manifestErrorResponse(new Error("Unauthorized"), 401);'
  );
  lines.push("  }");
  lines.push("");

  lines.push("  // 2. Tenant resolution");
  lines.push("  const tenantId = await getTenantIdForOrg(orgId);");
  lines.push("");

  // Only create runtime context for operations that need it (mutations)
  const needsRuntime = !["list", "get"].includes(operation.operation);

  if (needsRuntime) {
    lines.push("  // 3. Get current user");
    lines.push("  const currentUser = await database.user.findFirst({");
    lines.push("    where: {");
    lines.push(
      '      AND: [{ tenantId }, { authUserId: (await auth()).userId ?? "" }],'
    );
    lines.push("    },");
    lines.push("  });");
    lines.push("");

    lines.push("  if (!currentUser) {");
    lines.push(
      '    return manifestErrorResponse(new Error("User not found"), 400);'
    );
    lines.push("  }");
    lines.push("");

    lines.push("  // 4. Create runtime context");
    lines.push("  const runtimeContext: KitchenOpsContext = {");
    lines.push("    tenantId,");
    lines.push("    userId: currentUser.id,");
    lines.push("    userRole: currentUser.role,");
    lines.push(
      "    storeProvider: createPrismaStoreProvider(database, tenantId),"
    );
    lines.push("  };");
    lines.push("");

    lines.push("  // 5. Create runtime");
    lines.push(
      `  const runtime = await create${entityName}Runtime(runtimeContext);`
    );
    lines.push("");
  }

  lines.push(`  // ${needsRuntime ? "6" : "3"}. Execute operation`);
  lines.push("  try {");

  // Operation-specific logic
  switch (operation.operation) {
    case "list":
      lines.push(generateListOperation(entityName));
      break;
    case "get":
      lines.push(generateGetOperation(entityName));
      break;
    case "create":
      lines.push(generateCreateOperation(entityName));
      break;
    case "update":
      lines.push(generateUpdateOperation(entityName));
      break;
    case "delete":
      lines.push(generateDeleteOperation(entityName));
      break;
    case "command":
      lines.push(generateCommandOperation(entityName, operation));
      break;
    default:
      lines.push(`    // Unknown operation: ${operation.operation}`);
      lines.push(
        '    return manifestErrorResponse(new Error("Not implemented"), 501);'
      );
  }

  lines.push("  } catch (error) {");
  lines.push("    return manifestErrorResponse(error);");
  lines.push("  }");
  lines.push("}");

  return lines.join("\n");
}

/**
 * Generate LIST operation logic
 */
function generateListOperation(entityName: string): string {
  const lines: string[] = [];
  const modelName = entityName.charAt(0).toLowerCase() + entityName.slice(1);
  const pluralName = camelCasePlural(entityName);

  lines.push(`    // Query ${entityName} using Prisma (runtime is for commands, not queries)`);
  lines.push(`    const ${pluralName} = await database.${modelName}.findMany({`);
  lines.push("      where: {");
  lines.push("        tenantId,");
  lines.push("        deletedAt: null,");
  lines.push("      },");
  lines.push("      orderBy: {");
  lines.push('        createdAt: "desc",');
  lines.push("      },");
  lines.push("    });");
  lines.push("");
  lines.push(
    `    return manifestSuccessResponse({ ${pluralName} });`
  );

  return lines.join("\n");
}

/**
 * Generate GET operation logic
 */
function generateGetOperation(entityName: string): string {
  const lines: string[] = [];

  lines.push(`    // Get ${entityName} by ID`);
  lines.push("    const url = new URL(request.url);");
  lines.push(`    const id = url.pathname.split("/").pop();`);
  lines.push("    if (!id) {");
  lines.push(
    `      return manifestErrorResponse(new Error("Missing ID"), 400);`
  );
  lines.push("    }");
  lines.push("    ");
  lines.push(`    const item = await runtime.getById("${entityName}", id);`);
  lines.push("    if (!item) {");
  lines.push(
    `      return manifestErrorResponse(new Error("Not found"), 404);`
  );
  lines.push("    }");
  lines.push(
    `    return manifestSuccessResponse({ ${camelCase(entityName)}: item });`
  );

  return lines.join("\n");
}

/**
 * Generate CREATE operation logic with constraint checking
 */
function generateCreateOperation(entityName: string): string {
  const lines: string[] = [];

  lines.push("    // Parse request body");
  lines.push("    const body = await request.json();");
  lines.push("    ");
  lines.push("    // Call runtime and capture return value");
  lines.push(
    `    const result = await runtime.createInstance("${entityName}", body);`
  );
  lines.push("    ");
  lines.push("    // Check for constraint failure (undefined return)");
  lines.push("    if (result === undefined) {");
  lines.push("      // Get constraint details");
  lines.push(
    `      const failures = await runtime.checkConstraints("${entityName}", body);`
  );
  lines.push("      ");
  lines.push("      // Return error response with constraint details");
  lines.push(
    `      return manifestErrorResponse(new Error("Constraint validation failed"), 400, {`
  );
  lines.push("        constraints: failures.map((f: unknown) => ({");
  lines.push("          code: (f as { code?: string }).code,");
  lines.push("          message: (f as { message?: string }).message,");
  lines.push("          severity: (f as { severity?: string }).severity,");
  lines.push("        })),");
  lines.push("      }));");
  lines.push("    }");
  lines.push("    ");
  lines.push("    // Success - return created entity");
  lines.push("    return manifestSuccessResponse({");
  lines.push("      id: result.id,");
  lines.push("      ...result,");
  lines.push("    });");

  return lines.join("\n");
}

/**
 * Generate UPDATE operation logic with constraint checking
 */
function generateUpdateOperation(entityName: string): string {
  const lines: string[] = [];

  lines.push("    // Get ID from URL");
  lines.push("    const url = new URL(request.url);");
  lines.push(`    const id = url.pathname.split("/").pop();`);
  lines.push("    if (!id) {");
  lines.push(
    `      return manifestErrorResponse(new Error("Missing ID"), 400);`
  );
  lines.push("    }");
  lines.push("    ");
  lines.push("    // Parse request body");
  lines.push("    const body = await request.json();");
  lines.push("    ");
  lines.push("    // Execute update command");
  lines.push(
    `    const commandResult = await runtime.executeCommand(id, "update", {`
  );
  lines.push("      ...body,");
  lines.push("    });");
  lines.push("    ");
  lines.push("    // Check for blocking constraints");
  lines.push(
    "    const blockingConstraints = commandResult.constraintOutcomes?.filter("
  );
  lines.push("      (outcome: unknown) => {");
  lines.push(
    "        const o = outcome as { passed?: boolean; severity?: string; overridden?: boolean };"
  );
  lines.push(
    '        return !o.passed && o.severity === "block" && !o.overridden;'
  );
  lines.push("      }");
  lines.push("    );");
  lines.push("    ");
  lines.push(
    "    if (blockingConstraints && blockingConstraints.length > 0) {"
  );
  lines.push(
    `      return manifestErrorResponse(new Error("Command blocked by constraint"), 400, {`
  );
  lines.push("        constraintOutcomes: blockingConstraints,");
  lines.push("      });");
  lines.push("    }");
  lines.push("    ");
  lines.push("    // Success - return updated entity");
  lines.push("    return manifestSuccessResponse({");
  lines.push("      id,");
  lines.push("      ...commandResult.result,");
  lines.push("    });");

  return lines.join("\n");
}

/**
 * Generate DELETE operation logic
 */
function generateDeleteOperation(entityName: string): string {
  const lines: string[] = [];

  lines.push("    // Get ID from URL");
  lines.push("    const url = new URL(request.url);");
  lines.push(`    const id = url.pathname.split("/").pop();`);
  lines.push("    if (!id) {");
  lines.push(
    `      return manifestErrorResponse(new Error("Missing ID"), 400);`
  );
  lines.push("    }");
  lines.push("    ");
  lines.push("    // Execute delete command");
  lines.push(`    await runtime.executeCommand(id, "delete", {});`);
  lines.push("    ");
  lines.push("    // Success");
  lines.push("    return manifestSuccessResponse({ success: true });");

  return lines.join("\n");
}

/**
 * Generate COMMAND operation logic
 */
function generateCommandOperation(
  entityName: string,
  operation: RouteOperation
): string {
  const lines: string[] = [];

  const commandName = operation.path.split("/").pop() || "unknown";

  lines.push("    // Get ID from URL");
  lines.push("    const url = new URL(request.url);");
  lines.push(`    const pathParts = url.pathname.split("/");`);
  lines.push(
    `    const id = pathParts[pathParts.length - 3]; // .../:id/commands/${commandName}`
  );
  lines.push("    if (!id) {");
  lines.push(
    `      return manifestErrorResponse(new Error("Missing ID"), 400);`
  );
  lines.push("    }");
  lines.push("    ");
  lines.push("    // Parse request body");
  lines.push("    const body = await request.json();");
  lines.push("    ");
  lines.push("    // Execute command");
  lines.push(
    `    const result = await runtime.executeCommand(id, "${commandName}", body);`
  );
  lines.push("    ");
  lines.push("    // Check for blocking constraints");
  lines.push(
    "    const blockingConstraints = result.constraintOutcomes?.filter("
  );
  lines.push("      (outcome: unknown) => {");
  lines.push(
    "        const o = outcome as { passed?: boolean; severity?: string; overridden?: boolean };"
  );
  lines.push(
    '        return !o.passed && o.severity === "block" && !o.overridden;'
  );
  lines.push("      }");
  lines.push("    );");
  lines.push("    ");
  lines.push(
    "    if (blockingConstraints && blockingConstraints.length > 0) {"
  );
  lines.push(
    `      return manifestErrorResponse(new Error("Command blocked by constraint"), 400, {`
  );
  lines.push("        constraintOutcomes: blockingConstraints,");
  lines.push("      });");
  lines.push("    }");
  lines.push("    ");
  lines.push("    // Success - return command result");
  lines.push("    return manifestSuccessResponse({");
  lines.push("      result: result.result,");
  lines.push("    });");

  return lines.join("\n");
}

/**
 * Convert PascalCase to camelCase
 */
function camelCase(s: string): string {
  return s.charAt(0).toLowerCase() + s.slice(1);
}

/**
 * Convert PascalCase to camelCase plural
 */
function camelCasePlural(s: string): string {
  return camelCase(s) + "s";
}
