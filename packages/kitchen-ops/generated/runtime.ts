// Generated by Manifest Compiler v2.0
// This code is a PROJECTION from a Manifest source file.
// The IR (Intermediate Representation) is the single source of truth.
// This generated code should not be edited manually.
//
// Provenance:
//   Compiler Version: 0.3.0
//   Schema Version: 1.0
//   Generated At: 2026-02-09T16:19:47.449Z
//
// Includes: Commands, Computed Properties, Relationships, Policies, Stores, Events

type Subscriber<T> = (value: T) => void;
type User = { id: string; role?: string; [key: string]: unknown };
type Context = { user?: User; [key: string]: unknown };

let _context: Context = {};
const setContext = (ctx: Context) => { _context = ctx; };
const getContext = () => _context;

class Observable<T> {
  private subs: Set<Subscriber<T>> = new Set();
  private _v: T;
  constructor(v: T) { this._v = v; }
  get value(): T { return this._v; }
  set(v: T) { this._v = v; this.subs.forEach(fn => fn(v)); }
  subscribe(fn: Subscriber<T>) { this.subs.add(fn); fn(this._v); return () => this.subs.delete(fn); }
}

class EventEmitter<T extends Record<string, unknown>> {
  private listeners: Map<keyof T, Set<(d: unknown) => void>> = new Map();
  on<K extends keyof T>(e: K, fn: (d: T[K]) => void) { if (!this.listeners.has(e)) this.listeners.set(e, new Set()); this.listeners.get(e)!.add(fn); return () => this.listeners.get(e)?.delete(fn); }
  emit<K extends keyof T>(e: K, d: T[K]) { this.listeners.get(e)?.forEach(fn => fn(d)); }
}

class EventBus {
  private static channels: Map<string, Set<(d: unknown) => void>> = new Map();
  static publish(channel: string, data: unknown) { this.channels.get(channel)?.forEach(fn => fn(data)); }
  static subscribe(channel: string, fn: (d: unknown) => void) { if (!this.channels.has(channel)) this.channels.set(channel, new Set()); this.channels.get(channel)!.add(fn); return () => this.channels.get(channel)?.delete(fn); }
}

interface Store<T> {
  getAll(): Promise<T[]>;
  getById(id: string): Promise<T | null>;
  create(item: Partial<T>): Promise<T>;
  update(id: string, item: Partial<T>): Promise<T>;
  delete(id: string): Promise<boolean>;
  query(filter: (item: T) => boolean): Promise<T[]>;
}

class MemoryStore<T extends { id: string }> implements Store<T> {
  private data: Map<string, T> = new Map();
  async getAll() { return Array.from(this.data.values()); }
  async getById(id: string) { return this.data.get(id) || null; }
  async create(item: Partial<T>) { const id = item.id || crypto.randomUUID(); const full = { ...item, id } as T; this.data.set(id, full); return full; }
  async update(id: string, item: Partial<T>) { const existing = this.data.get(id); if (!existing) throw new Error("Not found"); const updated = { ...existing, ...item }; this.data.set(id, updated); return updated; }
  async delete(id: string) { return this.data.delete(id); }
  async query(filter: (item: T) => boolean) { return Array.from(this.data.values()).filter(filter); }
}

class LocalStorageStore<T extends { id: string }> implements Store<T> {
  constructor(private key: string) {}
  private load(): T[] { const d = localStorage.getItem(this.key); return d ? JSON.parse(d) : []; }
  private save(data: T[]) { localStorage.setItem(this.key, JSON.stringify(data)); }
  async getAll() { return this.load(); }
  async getById(id: string) { return this.load().find(x => x.id === id) || null; }
  async create(item: Partial<T>) { const data = this.load(); const id = item.id || crypto.randomUUID(); const full = { ...item, id } as T; data.push(full); this.save(data); return full; }
  async update(id: string, item: Partial<T>) { const data = this.load(); const idx = data.findIndex(x => x.id === id); if (idx < 0) throw new Error("Not found"); data[idx] = { ...data[idx], ...item }; this.save(data); return data[idx]; }
  async delete(id: string) { const data = this.load(); const idx = data.findIndex(x => x.id === id); if (idx < 0) return false; data.splice(idx, 1); this.save(data); return true; }
  async query(filter: (item: T) => boolean) { return this.load().filter(filter); }
}

interface IInventoryItem {
  id: string;
  tenantId: string;
  name: string;
  itemType: string;
  category?: string;
  baseUnit?: string;
  quantityOnHand?: number;
  quantityReserved?: number;
  quantityAvailable?: number;
  parLevel?: number;
  reorderPoint?: number;
  reorderQuantity?: number;
  costPerUnit?: number;
  supplierId?: string;
  locationId?: string;
  allergens?: string;
  isActive?: boolean;
  lastCountedAt?: number;
  createdAt?: number;
  updatedAt?: number;
  readonly isBelowPar: boolean;
  readonly isBelowReorderPoint: boolean;
  readonly totalValue: number;
  readonly reservedValue: number;
  readonly stockoutRisk: boolean;
  readonly lowStockRisk: boolean;
  readonly needsReorder: boolean;
}

class InventoryItem extends EventEmitter<{ InventoryReserved: unknown; InventoryConsumed: unknown; InventoryWasted: unknown; InventoryAdjusted: unknown; InventoryRestocked: unknown; InventoryReservationReleased: unknown }> {
  private _id = new Observable("");
  private _tenantId = new Observable("");
  private _name = new Observable("");
  private _itemType = new Observable("ingredient");
  private _category = new Observable("");
  private _baseUnit = new Observable("each");
  private _quantityOnHand = new Observable(0);
  private _quantityReserved = new Observable(0);
  private _quantityAvailable = new Observable(0);
  private _parLevel = new Observable(0);
  private _reorderPoint = new Observable(0);
  private _reorderQuantity = new Observable(0);
  private _costPerUnit = new Observable(0);
  private _supplierId = new Observable("");
  private _locationId = new Observable("");
  private _allergens = new Observable("");
  private _isActive = new Observable(true);
  private _lastCountedAt = new Observable(0);
  private _createdAt = new Observable(0);
  private _updatedAt = new Observable(0);
  
  get id() { return this._id.value; }
  set id(v: string) {
    if (!(((this.quantityOnHand >= 0) && (this.quantityReserved >= 0)))) throw new Error("Constraint 'positiveQuantities' violated");
    if (!((this.quantityReserved <= this.quantityOnHand))) throw new Error("Constraint 'reserveDoesNotExceedOnHand' violated");
    if (!(this.isBelowPar)) throw new Error("Constraint 'warnBelowPar' violated");
    if (!(this.lowStockRisk)) throw new Error("Constraint 'warnLowStock' violated");
    if (!(this.stockoutRisk)) throw new Error("Constraint 'blockStockout' violated");
    const old = this._id.value;
    this._id.set(v);
    if (old !== v) this._recompute();
  }
  get tenantId() { return this._tenantId.value; }
  set tenantId(v: string) {
    if (!(((this.quantityOnHand >= 0) && (this.quantityReserved >= 0)))) throw new Error("Constraint 'positiveQuantities' violated");
    if (!((this.quantityReserved <= this.quantityOnHand))) throw new Error("Constraint 'reserveDoesNotExceedOnHand' violated");
    if (!(this.isBelowPar)) throw new Error("Constraint 'warnBelowPar' violated");
    if (!(this.lowStockRisk)) throw new Error("Constraint 'warnLowStock' violated");
    if (!(this.stockoutRisk)) throw new Error("Constraint 'blockStockout' violated");
    const old = this._tenantId.value;
    this._tenantId.set(v);
    if (old !== v) this._recompute();
  }
  get name() { return this._name.value; }
  set name(v: string) {
    if (!(((this.quantityOnHand >= 0) && (this.quantityReserved >= 0)))) throw new Error("Constraint 'positiveQuantities' violated");
    if (!((this.quantityReserved <= this.quantityOnHand))) throw new Error("Constraint 'reserveDoesNotExceedOnHand' violated");
    if (!(this.isBelowPar)) throw new Error("Constraint 'warnBelowPar' violated");
    if (!(this.lowStockRisk)) throw new Error("Constraint 'warnLowStock' violated");
    if (!(this.stockoutRisk)) throw new Error("Constraint 'blockStockout' violated");
    const old = this._name.value;
    this._name.set(v);
    if (old !== v) this._recompute();
  }
  get itemType() { return this._itemType.value; }
  set itemType(v: string) {
    if (!(((this.quantityOnHand >= 0) && (this.quantityReserved >= 0)))) throw new Error("Constraint 'positiveQuantities' violated");
    if (!((this.quantityReserved <= this.quantityOnHand))) throw new Error("Constraint 'reserveDoesNotExceedOnHand' violated");
    if (!(this.isBelowPar)) throw new Error("Constraint 'warnBelowPar' violated");
    if (!(this.lowStockRisk)) throw new Error("Constraint 'warnLowStock' violated");
    if (!(this.stockoutRisk)) throw new Error("Constraint 'blockStockout' violated");
    const old = this._itemType.value;
    this._itemType.set(v);
    if (old !== v) this._recompute();
  }
  get category() { return this._category.value; }
  set category(v: string) {
    if (!(((this.quantityOnHand >= 0) && (this.quantityReserved >= 0)))) throw new Error("Constraint 'positiveQuantities' violated");
    if (!((this.quantityReserved <= this.quantityOnHand))) throw new Error("Constraint 'reserveDoesNotExceedOnHand' violated");
    if (!(this.isBelowPar)) throw new Error("Constraint 'warnBelowPar' violated");
    if (!(this.lowStockRisk)) throw new Error("Constraint 'warnLowStock' violated");
    if (!(this.stockoutRisk)) throw new Error("Constraint 'blockStockout' violated");
    const old = this._category.value;
    this._category.set(v);
    if (old !== v) this._recompute();
  }
  get baseUnit() { return this._baseUnit.value; }
  set baseUnit(v: string) {
    if (!(((this.quantityOnHand >= 0) && (this.quantityReserved >= 0)))) throw new Error("Constraint 'positiveQuantities' violated");
    if (!((this.quantityReserved <= this.quantityOnHand))) throw new Error("Constraint 'reserveDoesNotExceedOnHand' violated");
    if (!(this.isBelowPar)) throw new Error("Constraint 'warnBelowPar' violated");
    if (!(this.lowStockRisk)) throw new Error("Constraint 'warnLowStock' violated");
    if (!(this.stockoutRisk)) throw new Error("Constraint 'blockStockout' violated");
    const old = this._baseUnit.value;
    this._baseUnit.set(v);
    if (old !== v) this._recompute();
  }
  get quantityOnHand() { return this._quantityOnHand.value; }
  set quantityOnHand(v: number) {
    if (!(((v >= 0) && (this.quantityReserved >= 0)))) throw new Error("Constraint 'positiveQuantities' violated");
    if (!((this.quantityReserved <= v))) throw new Error("Constraint 'reserveDoesNotExceedOnHand' violated");
    if (!(this.isBelowPar)) throw new Error("Constraint 'warnBelowPar' violated");
    if (!(this.lowStockRisk)) throw new Error("Constraint 'warnLowStock' violated");
    if (!(this.stockoutRisk)) throw new Error("Constraint 'blockStockout' violated");
    const old = this._quantityOnHand.value;
    this._quantityOnHand.set(v);
    if (old !== v) this._recompute();
  }
  get quantityReserved() { return this._quantityReserved.value; }
  set quantityReserved(v: number) {
    if (!(((this.quantityOnHand >= 0) && (v >= 0)))) throw new Error("Constraint 'positiveQuantities' violated");
    if (!((v <= this.quantityOnHand))) throw new Error("Constraint 'reserveDoesNotExceedOnHand' violated");
    if (!(this.isBelowPar)) throw new Error("Constraint 'warnBelowPar' violated");
    if (!(this.lowStockRisk)) throw new Error("Constraint 'warnLowStock' violated");
    if (!(this.stockoutRisk)) throw new Error("Constraint 'blockStockout' violated");
    const old = this._quantityReserved.value;
    this._quantityReserved.set(v);
    if (old !== v) this._recompute();
  }
  get quantityAvailable() { return this._quantityAvailable.value; }
  set quantityAvailable(v: number) {
    if (!(((this.quantityOnHand >= 0) && (this.quantityReserved >= 0)))) throw new Error("Constraint 'positiveQuantities' violated");
    if (!((this.quantityReserved <= this.quantityOnHand))) throw new Error("Constraint 'reserveDoesNotExceedOnHand' violated");
    if (!(this.isBelowPar)) throw new Error("Constraint 'warnBelowPar' violated");
    if (!(this.lowStockRisk)) throw new Error("Constraint 'warnLowStock' violated");
    if (!(this.stockoutRisk)) throw new Error("Constraint 'blockStockout' violated");
    const old = this._quantityAvailable.value;
    this._quantityAvailable.set(v);
    if (old !== v) this._recompute();
  }
  get parLevel() { return this._parLevel.value; }
  set parLevel(v: number) {
    if (!(((this.quantityOnHand >= 0) && (this.quantityReserved >= 0)))) throw new Error("Constraint 'positiveQuantities' violated");
    if (!((this.quantityReserved <= this.quantityOnHand))) throw new Error("Constraint 'reserveDoesNotExceedOnHand' violated");
    if (!(this.isBelowPar)) throw new Error("Constraint 'warnBelowPar' violated");
    if (!(this.lowStockRisk)) throw new Error("Constraint 'warnLowStock' violated");
    if (!(this.stockoutRisk)) throw new Error("Constraint 'blockStockout' violated");
    const old = this._parLevel.value;
    this._parLevel.set(v);
    if (old !== v) this._recompute();
  }
  get reorderPoint() { return this._reorderPoint.value; }
  set reorderPoint(v: number) {
    if (!(((this.quantityOnHand >= 0) && (this.quantityReserved >= 0)))) throw new Error("Constraint 'positiveQuantities' violated");
    if (!((this.quantityReserved <= this.quantityOnHand))) throw new Error("Constraint 'reserveDoesNotExceedOnHand' violated");
    if (!(this.isBelowPar)) throw new Error("Constraint 'warnBelowPar' violated");
    if (!(this.lowStockRisk)) throw new Error("Constraint 'warnLowStock' violated");
    if (!(this.stockoutRisk)) throw new Error("Constraint 'blockStockout' violated");
    const old = this._reorderPoint.value;
    this._reorderPoint.set(v);
    if (old !== v) this._recompute();
  }
  get reorderQuantity() { return this._reorderQuantity.value; }
  set reorderQuantity(v: number) {
    if (!(((this.quantityOnHand >= 0) && (this.quantityReserved >= 0)))) throw new Error("Constraint 'positiveQuantities' violated");
    if (!((this.quantityReserved <= this.quantityOnHand))) throw new Error("Constraint 'reserveDoesNotExceedOnHand' violated");
    if (!(this.isBelowPar)) throw new Error("Constraint 'warnBelowPar' violated");
    if (!(this.lowStockRisk)) throw new Error("Constraint 'warnLowStock' violated");
    if (!(this.stockoutRisk)) throw new Error("Constraint 'blockStockout' violated");
    const old = this._reorderQuantity.value;
    this._reorderQuantity.set(v);
    if (old !== v) this._recompute();
  }
  get costPerUnit() { return this._costPerUnit.value; }
  set costPerUnit(v: number) {
    if (!(((this.quantityOnHand >= 0) && (this.quantityReserved >= 0)))) throw new Error("Constraint 'positiveQuantities' violated");
    if (!((this.quantityReserved <= this.quantityOnHand))) throw new Error("Constraint 'reserveDoesNotExceedOnHand' violated");
    if (!(this.isBelowPar)) throw new Error("Constraint 'warnBelowPar' violated");
    if (!(this.lowStockRisk)) throw new Error("Constraint 'warnLowStock' violated");
    if (!(this.stockoutRisk)) throw new Error("Constraint 'blockStockout' violated");
    const old = this._costPerUnit.value;
    this._costPerUnit.set(v);
    if (old !== v) this._recompute();
  }
  get supplierId() { return this._supplierId.value; }
  set supplierId(v: string) {
    if (!(((this.quantityOnHand >= 0) && (this.quantityReserved >= 0)))) throw new Error("Constraint 'positiveQuantities' violated");
    if (!((this.quantityReserved <= this.quantityOnHand))) throw new Error("Constraint 'reserveDoesNotExceedOnHand' violated");
    if (!(this.isBelowPar)) throw new Error("Constraint 'warnBelowPar' violated");
    if (!(this.lowStockRisk)) throw new Error("Constraint 'warnLowStock' violated");
    if (!(this.stockoutRisk)) throw new Error("Constraint 'blockStockout' violated");
    const old = this._supplierId.value;
    this._supplierId.set(v);
    if (old !== v) this._recompute();
  }
  get locationId() { return this._locationId.value; }
  set locationId(v: string) {
    if (!(((this.quantityOnHand >= 0) && (this.quantityReserved >= 0)))) throw new Error("Constraint 'positiveQuantities' violated");
    if (!((this.quantityReserved <= this.quantityOnHand))) throw new Error("Constraint 'reserveDoesNotExceedOnHand' violated");
    if (!(this.isBelowPar)) throw new Error("Constraint 'warnBelowPar' violated");
    if (!(this.lowStockRisk)) throw new Error("Constraint 'warnLowStock' violated");
    if (!(this.stockoutRisk)) throw new Error("Constraint 'blockStockout' violated");
    const old = this._locationId.value;
    this._locationId.set(v);
    if (old !== v) this._recompute();
  }
  get allergens() { return this._allergens.value; }
  set allergens(v: string) {
    if (!(((this.quantityOnHand >= 0) && (this.quantityReserved >= 0)))) throw new Error("Constraint 'positiveQuantities' violated");
    if (!((this.quantityReserved <= this.quantityOnHand))) throw new Error("Constraint 'reserveDoesNotExceedOnHand' violated");
    if (!(this.isBelowPar)) throw new Error("Constraint 'warnBelowPar' violated");
    if (!(this.lowStockRisk)) throw new Error("Constraint 'warnLowStock' violated");
    if (!(this.stockoutRisk)) throw new Error("Constraint 'blockStockout' violated");
    const old = this._allergens.value;
    this._allergens.set(v);
    if (old !== v) this._recompute();
  }
  get isActive() { return this._isActive.value; }
  set isActive(v: boolean) {
    if (!(((this.quantityOnHand >= 0) && (this.quantityReserved >= 0)))) throw new Error("Constraint 'positiveQuantities' violated");
    if (!((this.quantityReserved <= this.quantityOnHand))) throw new Error("Constraint 'reserveDoesNotExceedOnHand' violated");
    if (!(this.isBelowPar)) throw new Error("Constraint 'warnBelowPar' violated");
    if (!(this.lowStockRisk)) throw new Error("Constraint 'warnLowStock' violated");
    if (!(this.stockoutRisk)) throw new Error("Constraint 'blockStockout' violated");
    const old = this._isActive.value;
    this._isActive.set(v);
    if (old !== v) this._recompute();
  }
  get lastCountedAt() { return this._lastCountedAt.value; }
  set lastCountedAt(v: number) {
    if (!(((this.quantityOnHand >= 0) && (this.quantityReserved >= 0)))) throw new Error("Constraint 'positiveQuantities' violated");
    if (!((this.quantityReserved <= this.quantityOnHand))) throw new Error("Constraint 'reserveDoesNotExceedOnHand' violated");
    if (!(this.isBelowPar)) throw new Error("Constraint 'warnBelowPar' violated");
    if (!(this.lowStockRisk)) throw new Error("Constraint 'warnLowStock' violated");
    if (!(this.stockoutRisk)) throw new Error("Constraint 'blockStockout' violated");
    const old = this._lastCountedAt.value;
    this._lastCountedAt.set(v);
    if (old !== v) this._recompute();
  }
  get createdAt() { return this._createdAt.value; }
  set createdAt(v: number) {
    if (!(((this.quantityOnHand >= 0) && (this.quantityReserved >= 0)))) throw new Error("Constraint 'positiveQuantities' violated");
    if (!((this.quantityReserved <= this.quantityOnHand))) throw new Error("Constraint 'reserveDoesNotExceedOnHand' violated");
    if (!(this.isBelowPar)) throw new Error("Constraint 'warnBelowPar' violated");
    if (!(this.lowStockRisk)) throw new Error("Constraint 'warnLowStock' violated");
    if (!(this.stockoutRisk)) throw new Error("Constraint 'blockStockout' violated");
    const old = this._createdAt.value;
    this._createdAt.set(v);
    if (old !== v) this._recompute();
  }
  get updatedAt() { return this._updatedAt.value; }
  set updatedAt(v: number) {
    if (!(((this.quantityOnHand >= 0) && (this.quantityReserved >= 0)))) throw new Error("Constraint 'positiveQuantities' violated");
    if (!((this.quantityReserved <= this.quantityOnHand))) throw new Error("Constraint 'reserveDoesNotExceedOnHand' violated");
    if (!(this.isBelowPar)) throw new Error("Constraint 'warnBelowPar' violated");
    if (!(this.lowStockRisk)) throw new Error("Constraint 'warnLowStock' violated");
    if (!(this.stockoutRisk)) throw new Error("Constraint 'blockStockout' violated");
    const old = this._updatedAt.value;
    this._updatedAt.set(v);
    if (old !== v) this._recompute();
  }
  private _computed_isBelowPar: boolean = false;
  get isBelowPar() { return this._computed_isBelowPar; }
  private _computed_isBelowReorderPoint: boolean = false;
  get isBelowReorderPoint() { return this._computed_isBelowReorderPoint; }
  private _computed_totalValue: number = 0;
  get totalValue() { return this._computed_totalValue; }
  private _computed_reservedValue: number = 0;
  get reservedValue() { return this._computed_reservedValue; }
  private _computed_stockoutRisk: boolean = false;
  get stockoutRisk() { return this._computed_stockoutRisk; }
  private _computed_lowStockRisk: boolean = false;
  get lowStockRisk() { return this._computed_lowStockRisk; }
  private _computed_needsReorder: boolean = false;
  get needsReorder() { return this._computed_needsReorder; }
  
  constructor(init?: Partial<IInventoryItem>) {
    super();
    if (init) {
      if (init.id !== undefined) this._id.set(init.id);
      if (init.tenantId !== undefined) this._tenantId.set(init.tenantId);
      if (init.name !== undefined) this._name.set(init.name);
      if (init.itemType !== undefined) this._itemType.set(init.itemType);
      if (init.category !== undefined) this._category.set(init.category);
      if (init.baseUnit !== undefined) this._baseUnit.set(init.baseUnit);
      if (init.quantityOnHand !== undefined) this._quantityOnHand.set(init.quantityOnHand);
      if (init.quantityReserved !== undefined) this._quantityReserved.set(init.quantityReserved);
      if (init.quantityAvailable !== undefined) this._quantityAvailable.set(init.quantityAvailable);
      if (init.parLevel !== undefined) this._parLevel.set(init.parLevel);
      if (init.reorderPoint !== undefined) this._reorderPoint.set(init.reorderPoint);
      if (init.reorderQuantity !== undefined) this._reorderQuantity.set(init.reorderQuantity);
      if (init.costPerUnit !== undefined) this._costPerUnit.set(init.costPerUnit);
      if (init.supplierId !== undefined) this._supplierId.set(init.supplierId);
      if (init.locationId !== undefined) this._locationId.set(init.locationId);
      if (init.allergens !== undefined) this._allergens.set(init.allergens);
      if (init.isActive !== undefined) this._isActive.set(init.isActive);
      if (init.lastCountedAt !== undefined) this._lastCountedAt.set(init.lastCountedAt);
      if (init.createdAt !== undefined) this._createdAt.set(init.createdAt);
      if (init.updatedAt !== undefined) this._updatedAt.set(init.updatedAt);
    }
    this._initBehaviors();
    this._recompute();
  }
  
  private _recompute() {
    this._computed_isBelowPar = ((this.parLevel > 0) && (this.quantityOnHand < this.parLevel));
    this._computed_isBelowReorderPoint = ((this.reorderPoint > 0) && (this.quantityOnHand < this.reorderPoint));
    this._computed_totalValue = (this.quantityOnHand * this.costPerUnit);
    this._computed_reservedValue = (this.quantityReserved * this.costPerUnit);
    this._computed_stockoutRisk = (this.quantityAvailable <= 0);
    this._computed_lowStockRisk = (this.quantityAvailable < (this.parLevel * 0.25));
    this._computed_needsReorder = this.isBelowReorderPoint;
  }
  
  private _initBehaviors() {
  }
  
  subscribe(prop: keyof IInventoryItem, fn: (v: unknown) => void) { return (this as Record<string, unknown>)[`_${prop}`]?.subscribe?.(fn); }
  
  toJSON() {
    return {
      id: this.id,
      tenantId: this.tenantId,
      name: this.name,
      itemType: this.itemType,
      category: this.category,
      baseUnit: this.baseUnit,
      quantityOnHand: this.quantityOnHand,
      quantityReserved: this.quantityReserved,
      quantityAvailable: this.quantityAvailable,
      parLevel: this.parLevel,
      reorderPoint: this.reorderPoint,
      reorderQuantity: this.reorderQuantity,
      costPerUnit: this.costPerUnit,
      supplierId: this.supplierId,
      locationId: this.locationId,
      allergens: this.allergens,
      isActive: this.isActive,
      lastCountedAt: this.lastCountedAt,
      createdAt: this.createdAt,
      updatedAt: this.updatedAt,
      isBelowPar: this.isBelowPar,
      isBelowReorderPoint: this.isBelowReorderPoint,
      totalValue: this.totalValue,
      reservedValue: this.reservedValue,
      stockoutRisk: this.stockoutRisk,
      lowStockRisk: this.lowStockRisk,
      needsReorder: this.needsReorder,
    };
  }
  
  async reserve(quantity: number, eventId: string, userId: string): Promise<unknown> {
    // Guard checks
    if (!(((quantity != null) && (quantity > 0)))) throw new Error("Guard failed for reserve");
    if (!(((eventId != null) && (eventId != "")))) throw new Error("Guard failed for reserve");
    let _result: unknown;
    _result = this.quantityReserved = (this.quantityReserved + quantity);;
    _result = this.updatedAt = now();;
    _result = this.emit('InventoryReserved', {});;
    this.emit('InventoryReserved', { quantity, eventId, userId });
    return _result as unknown;
  }
  
  async consume(quantity: number, lotId: string, userId: string): Promise<unknown> {
    // Guard checks
    if (!(((quantity != null) && (quantity > 0)))) throw new Error("Guard failed for consume");
    let _result: unknown;
    _result = this.quantityOnHand = (this.quantityOnHand - quantity);;
    _result = this.quantityReserved = ((this.quantityReserved > quantity) ? (this.quantityReserved - quantity) : 0);;
    _result = this.updatedAt = now();;
    _result = this.emit('InventoryConsumed', {});;
    this.emit('InventoryConsumed', { quantity, lotId, userId });
    return _result as unknown;
  }
  
  async waste(quantity: number, reason: string, lotId: string, userId: string): Promise<unknown> {
    // Guard checks
    if (!(((quantity != null) && (quantity > 0)))) throw new Error("Guard failed for waste");
    if (!(((reason != null) && (reason != "")))) throw new Error("Guard failed for waste");
    let _result: unknown;
    _result = this.quantityOnHand = (this.quantityOnHand - quantity);;
    _result = this.quantityReserved = ((this.quantityReserved > quantity) ? (this.quantityReserved - quantity) : 0);;
    _result = this.updatedAt = now();;
    _result = this.emit('InventoryWasted', {});;
    this.emit('InventoryWasted', { quantity, reason, lotId, userId });
    return _result as unknown;
  }
  
  async adjust(quantity: number, reason: string, userId: string): Promise<unknown> {
    // Guard checks
    if (!(((reason != null) && (reason != "")))) throw new Error("Guard failed for adjust");
    let _result: unknown;
    _result = this.quantityOnHand = (this.quantityOnHand + quantity);;
    _result = this.updatedAt = now();;
    _result = this.emit('InventoryAdjusted', {});;
    this.emit('InventoryAdjusted', { quantity, reason, userId });
    return _result as unknown;
  }
  
  async restock(quantity: number, costPerUnit: number, userId: string): Promise<unknown> {
    // Guard checks
    if (!(((quantity != null) && (quantity > 0)))) throw new Error("Guard failed for restock");
    if (!(((costPerUnit != null) && (costPerUnit >= 0)))) throw new Error("Guard failed for restock");
    let _result: unknown;
    _result = this.quantityOnHand = (this.quantityOnHand + quantity);;
    _result = this.costPerUnit = costPerUnit;;
    _result = this.updatedAt = now();;
    _result = this.emit('InventoryRestocked', {});;
    this.emit('InventoryRestocked', { quantity, costPerUnit, userId });
    return _result as unknown;
  }
  
  async releaseReservation(quantity: number, eventId: string, userId: string): Promise<unknown> {
    // Guard checks
    if (!(((quantity != null) && (quantity > 0)))) throw new Error("Guard failed for releaseReservation");
    if (!(((eventId != null) && (eventId != "")))) throw new Error("Guard failed for releaseReservation");
    let _result: unknown;
    _result = this.quantityReserved = ((this.quantityReserved > quantity) ? (this.quantityReserved - quantity) : 0);;
    _result = this.updatedAt = now();;
    _result = this.emit('InventoryReservationReleased', {});;
    this.emit('InventoryReservationReleased', { quantity, eventId, userId });
    return _result as unknown;
  }
}

interface InventoryReservedEvent { itemId: string; itemName: string; quantity: number; eventId: string; userId: string; reservedAt: number }

const publishInventoryReserved = (data: InventoryReservedEvent) => {
  EventBus.publish('kitchen.inventory.reserved', data);
};

interface InventoryConsumedEvent { itemId: string; itemName: string; quantity: number; lotId: string; userId: string; consumedAt: number }

const publishInventoryConsumed = (data: InventoryConsumedEvent) => {
  EventBus.publish('kitchen.inventory.consumed', data);
};

interface InventoryWastedEvent { itemId: string; itemName: string; quantity: number; reason: string; lotId: string; userId: string; wastedAt: number }

const publishInventoryWasted = (data: InventoryWastedEvent) => {
  EventBus.publish('kitchen.inventory.wasted', data);
};

interface InventoryAdjustedEvent { itemId: string; itemName: string; quantity: number; reason: string; userId: string; adjustedAt: number }

const publishInventoryAdjusted = (data: InventoryAdjustedEvent) => {
  EventBus.publish('kitchen.inventory.adjusted', data);
};

interface InventoryRestockedEvent { itemId: string; itemName: string; quantity: number; costPerUnit: number; userId: string; restockedAt: number }

const publishInventoryRestocked = (data: InventoryRestockedEvent) => {
  EventBus.publish('kitchen.inventory.restocked', data);
};

interface InventoryReservationReleasedEvent { itemId: string; itemName: string; quantity: number; eventId: string; userId: string; releasedAt: number }

const publishInventoryReservationReleased = (data: InventoryReservationReleasedEvent) => {
  EventBus.publish('kitchen.inventory.reservation.released', data);
};


export { setContext, getContext, EventBus, InventoryItem, publishInventoryReserved, subscribeInventoryReserved, publishInventoryConsumed, subscribeInventoryConsumed, publishInventoryWasted, subscribeInventoryWasted, publishInventoryAdjusted, subscribeInventoryAdjusted, publishInventoryRestocked, subscribeInventoryRestocked, publishInventoryReservationReleased, subscribeInventoryReservationReleased };