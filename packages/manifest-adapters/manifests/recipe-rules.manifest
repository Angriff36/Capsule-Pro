// Kitchen Ops - Recipe Rules
// Manifest spec for recipe operations with constraints, guards, and events

entity Recipe {
  property required id: string
  property required tenantId: string
  property required name: string
  property category: string = ""
  property cuisineType: string = ""
  property description: string = ""
  property tags: string = ""
  property isActive: boolean = true

  computed hasVersion: boolean = true
  computed tagCount: number = length(split(self.tags, ","))

  constraint validName: self.name != null and self.name != "" "Recipe name is required"
  constraint validTags: self.tags == null or self.tags == "" or length(split(self.tags, ",")) <= 20 "Recipe cannot have more than 20 tags"

  command update(newName: string, newCategory: string, newCuisineType: string, newDescription: string, newTags: string) {
    guard newName != null and newName != "" "Recipe name is required"

    constraint warnNameChange:warn self.name != newName {
      messageTemplate: "Renaming recipe from '{oldName}' to '{newName}'"
      details: {
        oldName: self.name
        newName: newName
      }
    }

    mutate name = newName
    mutate category = newCategory
    mutate cuisineType = newCuisineType
    mutate description = newDescription
    mutate tags = newTags

    emit RecipeUpdated
  }

  command deactivate(reason: string) {
    guard self.isActive == true "Recipe is already inactive"

    mutate isActive = false

    emit RecipeDeactivated
  }

  command activate() {
    guard self.isActive == false "Recipe is already active"

    mutate isActive = true

    emit RecipeActivated
  }

  command create(name: string, category: string, cuisineType: string, description: string, tags: string) {
    guard name != null and name != "" "Recipe name is required"

    mutate name = name
    mutate category = category
    mutate cuisineType = cuisineType
    mutate description = description
    mutate tags = tags
    mutate isActive = true

    emit RecipeCreated
  }

  store Recipe in memory
}

entity RecipeVersion {
  property required id: string
  property required recipeId: string
  property required tenantId: string
  property required name: string
  property required versionNumber: number
  property category: string = ""
  property cuisineType: string = ""
  property description: string = ""
  property tags: string = ""
  property yieldQuantity: number = 1
  property yieldUnitId: number = 1
  property yieldDescription: string = ""
  property prepTimeMinutes: number = 0
  property cookTimeMinutes: number = 0
  property restTimeMinutes: number = 0
  property difficultyLevel: number = 1
  property instructions: string = ""
  property notes: string = ""
  property ingredientCount: number = 0
  property stepCount: number = 0
  property createdAt: number = 0

  computed totalTimeMinutes: number = self.prepTimeMinutes + self.cookTimeMinutes + self.restTimeMinutes
  computed isVersion1: boolean = self.versionNumber == 1
  computed isHighDifficulty: boolean = self.difficultyLevel >= 4

  constraint validVersionNumber: self.versionNumber > 0 "Version number must be positive"
  constraint positiveYield: self.yieldQuantity > 0 "Yield quantity must be positive"
  constraint validDifficulty: self.difficultyLevel >= 1 and self.difficultyLevel <= 5 "Difficulty must be between 1 (easy) and 5 (expert)"
  constraint validTimes: self.prepTimeMinutes >= 0 and self.cookTimeMinutes >= 0 and self.restTimeMinutes >= 0 "Time values must be non-negative"

  constraint warnLongRecipe:warn self.totalTimeMinutes > 480 {
    messageTemplate: "Recipe takes {totalHours}+ hours to complete"
    details: {
      totalTimeMinutes: self.totalTimeMinutes
      totalHours: self.totalTimeMinutes / 60
    }
  }

  constraint warnHighDifficulty:warn self.difficultyLevel >= 4 {
    messageTemplate: "High difficulty recipe (level {difficulty}) - requires skilled staff"
    details: {
      difficultyLevel: self.difficultyLevel
    }
  }

  command create(yieldQty: number, yieldUnit: number, prepTime: number, cookTime: number, restTime: number, difficulty: number, instructionsText: string, notesText: string) {
    guard yieldQty != null and yieldQty > 0 "Yield quantity must be positive"
    guard yieldUnit != null and yieldUnit > 0 "Yield unit is required"

    mutate yieldQuantity = yieldQty
    mutate yieldUnitId = yieldUnit
    mutate prepTimeMinutes = prepTime
    mutate cookTimeMinutes = cookTime
    mutate restTimeMinutes = restTime
    mutate difficultyLevel = difficulty
    mutate instructions = instructionsText
    mutate notes = notesText
    mutate createdAt = now()

    emit RecipeVersionCreated
  }

  command restore(sourceId: string, newVersionNum: number) {
    guard sourceId != null and sourceId != "" "Source version ID is required"
    guard newVersionNum != null and newVersionNum > 0 "Version number must be positive"

    mutate versionNumber = newVersionNum
    mutate createdAt = now()

    emit RecipeVersionRestored
  }

  store RecipeVersion in memory
}

entity Ingredient {
  property required id: string
  property required tenantId: string
  property required name: string
  property required defaultUnitId: number
  property category: string = ""
  property allergens: string = ""
  property isActive: boolean = true

  constraint validName: self.name != null and self.name != "" "Ingredient name is required"

  constraint warnMajorAllergen:warn self.allergens != null and (self.allergens contains "nuts" or self.allergens contains "dairy" or self.allergens contains "gluten") {
    messageTemplate: "Ingredient contains major allergen: {allergens}"
    details: {
      allergens: self.allergens
    }
  }

  command updateAllergens(newAllergens: string) {
    mutate allergens = newAllergens

    emit IngredientAllergensUpdated
  }

  command create(name: string, defaultUnitId: number, category: string, allergens: string) {
    guard name != null and name != "" "Ingredient name is required"
    guard defaultUnitId > 0 "Default unit is required"

    mutate name = name
    mutate defaultUnitId = defaultUnitId
    mutate category = category
    mutate allergens = allergens
    mutate isActive = true

    emit IngredientCreated
  }

  store Ingredient in memory
}

entity RecipeIngredient {
  property required id: string
  property required tenantId: string
  property required recipeVersionId: string
  property required ingredientId: string
  property required quantity: number
  property required unitId: number
  property required sortOrder: number
  property preparationNotes: string = ""
  property isOptional: boolean = false
  property deletedAt: number = 0

  constraint positiveQuantity: self.quantity > 0 "Ingredient quantity must be positive"
  constraint validOrder: self.sortOrder > 0 "Sort order must be positive"

  command updateQuantity(newQuantity: number, newUnit: number) {
    guard newQuantity != null and newQuantity > 0 "Quantity must be positive"

    constraint warnQuantityIncrease:warn newQuantity > self.quantity * 1.5 {
      messageTemplate: "Ingredient quantity increased by 50% or more"
      details: {
        oldQuantity: self.quantity
        newQuantity: newQuantity
        increasePercent: ((newQuantity - self.quantity) / self.quantity) * 100
      }
    }

    mutate quantity = newQuantity
    mutate unitId = newUnit

    emit RecipeIngredientUpdated
  }

  command create(recipeVersionId: string, ingredientId: string, quantity: number, unitId: number, sortOrder: number, preparationNotes: string, isOptional: boolean) {
    guard recipeVersionId != null and recipeVersionId != "" "Recipe version ID is required"
    guard ingredientId != null and ingredientId != "" "Ingredient ID is required"
    guard quantity > 0 "Quantity must be positive"
    guard unitId > 0 "Unit is required"

    mutate recipeVersionId = recipeVersionId
    mutate ingredientId = ingredientId
    mutate quantity = quantity
    mutate unitId = unitId
    mutate sortOrder = sortOrder
    mutate preparationNotes = preparationNotes
    mutate isOptional = isOptional

    emit RecipeIngredientCreated
  }

  command remove(userId: string) {
    mutate deletedAt = now()

    emit RecipeIngredientRemoved
  }

  store RecipeIngredient in memory
}

entity RecipeStep {
  property required id: string
  property required tenantId: string
  property required recipeVersionId: string
  property required stepNumber: number
  property required instruction: string
  property durationMinutes: number = 0
  property temperatureValue: number = 0
  property temperatureUnit: string = ""
  property equipmentNeeded: string = ""
  property tips: string = ""
  property videoUrl: string = ""
  property imageUrl: string = ""
  property deletedAt: number = 0

  constraint positiveStepNumber: self.stepNumber > 0 "Step number must be positive"
  constraint validInstruction: self.instruction != null and self.instruction != "" "Instruction is required"

  command create(recipeVersionId: string, stepNumber: number, instruction: string, durationMinutes: number, temperatureValue: number, temperatureUnit: string, equipmentNeeded: string, tips: string, videoUrl: string, imageUrl: string) {
    guard recipeVersionId != null and recipeVersionId != "" "Recipe version ID is required"
    guard stepNumber > 0 "Step number must be positive"
    guard instruction != null and instruction != "" "Instruction is required"

    mutate recipeVersionId = recipeVersionId
    mutate stepNumber = stepNumber
    mutate instruction = instruction
    mutate durationMinutes = durationMinutes
    mutate temperatureValue = temperatureValue
    mutate temperatureUnit = temperatureUnit
    mutate equipmentNeeded = equipmentNeeded
    mutate tips = tips
    mutate videoUrl = videoUrl
    mutate imageUrl = imageUrl

    emit RecipeStepCreated
  }

  command updateInstruction(newInstruction: string, newDurationMinutes: number, newTips: string) {
    guard newInstruction != null and newInstruction != "" "Instruction is required"

    mutate instruction = newInstruction
    mutate durationMinutes = newDurationMinutes
    mutate tips = newTips

    emit RecipeStepUpdated
  }

  command remove(userId: string) {
    mutate deletedAt = now()

    emit RecipeStepRemoved
  }

  store RecipeStep in memory
}

entity Dish {
  property required id: string
  property required tenantId: string
  property required name: string
  property recipeId: string = ""
  property description: string = ""
  property category: string = ""
  property serviceStyle: string = ""
  property presentationImageUrl: string = ""
  property dietaryTags: string = ""
  property allergens: string = ""
  property pricePerPerson: number = 0
  property costPerPerson: number = 0
  property minPrepLeadDays: number = 1
  property maxPrepLeadDays: number = 7
  property portionSizeDescription: string = ""
  property isActive: boolean = true

  constraint validName: self.name != null and self.name != "" "Dish name is required"
  constraint validLeadDays: self.minPrepLeadDays >= 0 and self.maxPrepLeadDays >= self.minPrepLeadDays "Lead days must be valid"
  constraint positivePrice: self.pricePerPerson >= 0 "Price must be non-negative"
  constraint positiveCost: self.costPerPerson >= 0 and self.costPerPerson <= self.pricePerPerson "Cost must be non-negative and not exceed price"

  constraint warnTightMargin:warn self.pricePerPerson > 0 and (self.costPerPerson / self.pricePerPerson) > 0.7 {
    messageTemplate: "Dish has tight profit margin ({marginPercent}% cost)"
    details: {
      costPerPerson: self.costPerPerson
      pricePerPerson: self.pricePerPerson
      marginPercent: (self.costPerPerson / self.pricePerPerson) * 100
    }
  }

  constraint warnLongLeadTime:warn self.minPrepLeadDays > 3 {
    messageTemplate: "Dish requires {days} days advance notice"
    details: {
      minPrepLeadDays: self.minPrepLeadDays
    }
  }

  command updatePricing(newPrice: number, newCost: number) {
    guard newPrice != null and newPrice >= 0 "Price must be non-negative"
    guard newCost != null and newCost >= 0 "Cost must be non-negative"

    constraint warnPriceDecrease:warn newPrice < self.pricePerPerson {
      messageTemplate: "Price decreased from {oldPrice} to {newPrice}"
      details: {
        oldPrice: self.pricePerPerson
        newPrice: newPrice
      }
    }

    constraint warnMarginBelowThreshold:warn newPrice > 0 and (newCost / newPrice) > 0.75 {
      messageTemplate: "New pricing has low profit margin ({marginPercent}% cost)"
      details: {
        costPerPerson: newCost
        pricePerPerson: newPrice
        marginPercent: (newCost / newPrice) * 100
      }
    }

    mutate pricePerPerson = newPrice
    mutate costPerPerson = newCost

    emit DishPricingUpdated
  }

  command updateLeadTime(minDays: number, maxDays: number) {
    guard minDays != null and minDays >= 0 "Minimum lead days must be non-negative"
    guard maxDays != null and maxDays >= minDays "Maximum lead days must be >= minimum"

    mutate minPrepLeadDays = minDays
    mutate maxPrepLeadDays = maxDays

    emit DishLeadTimeUpdated
  }

  command create(name: string, recipeId: string, description: string, category: string, serviceStyle: string, dietaryTags: string, allergens: string, pricePerPerson: number, costPerPerson: number, minPrepLeadDays: number, maxPrepLeadDays: number, portionSizeDescription: string) {
    guard name != null and name != "" "Dish name is required"
    guard minPrepLeadDays >= 0 "Minimum lead days must be non-negative"
    guard maxPrepLeadDays >= minPrepLeadDays "Maximum lead days must be >= minimum"
    guard pricePerPerson >= 0 "Price must be non-negative"
    guard costPerPerson >= 0 "Cost must be non-negative"

    mutate name = name
    mutate recipeId = recipeId
    mutate description = description
    mutate category = category
    mutate serviceStyle = serviceStyle
    mutate dietaryTags = dietaryTags
    mutate allergens = allergens
    mutate pricePerPerson = pricePerPerson
    mutate costPerPerson = costPerPerson
    mutate minPrepLeadDays = minPrepLeadDays
    mutate maxPrepLeadDays = maxPrepLeadDays
    mutate portionSizeDescription = portionSizeDescription
    mutate isActive = true

    emit DishCreated
  }

  store Dish in memory
}

// Policy definitions
policy RecipeManagement execute: user.role in ["kitchen_staff", "kitchen_lead", "manager", "admin"] "Kitchen staff can manage recipes"
policy RecipeDelete execute: user.role in ["kitchen_lead", "manager", "admin"] "Only leads and above can delete recipes"
policy PricingUpdate execute: user.role in ["kitchen_lead", "manager", "admin"] "Only leads and above can update pricing"

// Event definitions
event RecipeCreated: "kitchen.recipe.created" {
  recipeId: string
  tenantId: string
  name: string
  createdAt: number
}

event RecipeUpdated: "kitchen.recipe.updated" {
  recipeId: string
  tenantId: string
  oldName: string
  newName: string
  updatedAt: number
}

event RecipeDeactivated: "kitchen.recipe.deactivated" {
  recipeId: string
  tenantId: string
  name: string
  reason: string
  deactivatedAt: number
}

event RecipeActivated: "kitchen.recipe.activated" {
  recipeId: string
  tenantId: string
  name: string
  activatedAt: number
}

event RecipeVersionCreated: "kitchen.recipe.version.created" {
  versionId: string
  recipeId: string
  tenantId: string
  versionNumber: number
  yieldQuantity: number
  createdAt: number
}

event RecipeVersionRestored: "kitchen.recipe.version.restored" {
  newVersionId: string
  sourceVersionId: string
  recipeId: string
  tenantId: string
  versionNumber: number
  restoredAt: number
}

event IngredientAllergensUpdated: "kitchen.ingredient.allergens.updated" {
  ingredientId: string
  tenantId: string
  oldAllergens: string
  newAllergens: string
  updatedAt: number
}

event IngredientCreated: "kitchen.ingredient.created" {
  ingredientId: string
  tenantId: string
  name: string
  category: string
  allergens: string
  createdAt: number
}

event RecipeIngredientCreated: "kitchen.recipe.ingredient.created" {
  recipeIngredientId: string
  recipeVersionId: string
  ingredientId: string
  tenantId: string
  quantity: number
  createdAt: number
}

event RecipeIngredientUpdated: "kitchen.recipe.ingredient.updated" {
  recipeIngredientId: string
  recipeVersionId: string
  ingredientId: string
  oldQuantity: number
  newQuantity: number
  updatedAt: number
}

event RecipeStepCreated: "kitchen.recipe.step.created" {
  recipeStepId: string
  recipeVersionId: string
  tenantId: string
  stepNumber: number
  instruction: string
  createdAt: number
}

event RecipeStepUpdated: "kitchen.recipe.step.updated" {
  recipeStepId: string
  recipeVersionId: string
  tenantId: string
  stepNumber: number
  oldInstruction: string
  newInstruction: string
  updatedAt: number
}

event RecipeStepRemoved: "kitchen.recipe.step.removed" {
  recipeStepId: string
  recipeVersionId: string
  tenantId: string
  stepNumber: number
  removedAt: number
}

event DishCreated: "kitchen.dish.created" {
  dishId: string
  tenantId: string
  name: string
  recipeId: string
  createdAt: number
}

event DishPricingUpdated: "kitchen.dish.pricing.updated" {
  dishId: string
  tenantId: string
  oldPrice: number
  newPrice: number
  oldCost: number
  newCost: number
  updatedAt: number
}

event RecipeIngredientRemoved: "kitchen.recipeingredient.removed" {
  recipeIngredientId: string
  recipeVersionId: string
  ingredientId: string
  tenantId: string
  userId: string
  removedAt: number
}

event DishLeadTimeUpdated: "kitchen.dish.leadtime.updated" {
  dishId: string
  tenantId: string
  oldMinDays: number
  newMinDays: number
  oldMaxDays: number
  newMaxDays: number
  updatedAt: number
}
