/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
// @ts-nocheck

/*=============================================================================
 * This file was automatically generated by the BaseHub SDK and contains type
 * definitions based on your repository schema. Credits to https://genql.dev/
 * for the type generation.
 *
 * You can safely commit this to version control.
 *============================================================================*/

declare module "basehub" {
  export interface Query extends _Query {}
  export interface QueryGenqlSelection extends _QueryGenqlSelection {}
  export interface Mutation extends _Mutation {}
  export interface MutationGenqlSelection extends _MutationGenqlSelection {}
  export interface FragmentsMap extends _FragmentsMap {}
  export interface Scalars extends _Scalars {}
}

import type { Transaction } from "basehub/api-transaction";

interface _Query extends Query {}
interface _QueryGenqlSelection extends QueryGenqlSelection {}
interface _Mutation extends Mutation {}
interface _MutationGenqlSelection extends MutationGenqlSelection {}
interface _FragmentsMap extends FragmentsMap {}
interface _Scalars extends Scalars {}

export type Scalars = {
  BSHBEventSchema: ({
    name: string;
    required: boolean;
    placeholder?: string;
    defaultValue?: string;
    helpText?: string;
  } & {
    id: string;
    label: string;
  } & (
      | {
          type:
            | "text"
            | "textarea"
            | "number"
            | "date"
            | "datetime"
            | "email"
            | "checkbox"
            | "hidden";
        }
      | {
          type: "select" | "radio";
          options: string[];
          multiple: boolean;
        }
      | {
          type: "file";
        }
    ))[];
  BSHBRichTextContentSchema: RichTextNode[];
  BSHBRichTextTOCSchema: RichTextTocNode[];
  Boolean: boolean;
  CodeSnippetLanguage: B_Language;
  DateTime: any;
  Float: number;
  ID: string;
  Int: number;
  JSON: any;
  String: string;
};

export type AnalyticsKeyScope = "query" | "send";

export type Authors = {
  _analyticsKey: Scalars["String"];
  _dashboardUrl: Scalars["String"];
  _id: Scalars["String"];
  _idPath: Scalars["String"];
  _meta: ListMeta;
  /** The key used to search from the frontend. */
  _searchKey: Scalars["String"];
  _slug: Scalars["String"];
  _slugPath: Scalars["String"];
  _sys: BlockDocumentSys;
  _title: Scalars["String"];
  /** Returns the first item in the list, or null if the list is empty. Useful when you expect only one result. */
  item: AuthorsItem | null;
  /** Returns the list of items after filtering and paginating according to the arguments sent by the client. */
  items: AuthorsItem[];
  __typename: "Authors";
};

export type AuthorsItem = {
  _analyticsKey: Scalars["String"];
  _dashboardUrl: Scalars["String"];
  /** Array of search highlight information with field names and HTML markup */
  _highlight: SearchHighlight[] | null;
  _id: Scalars["String"];
  _idPath: Scalars["String"];
  _slug: Scalars["String"];
  _slugPath: Scalars["String"];
  _sys: BlockDocumentSys;
  _title: Scalars["String"];
  avatar: BlockImage;
  xUrl: Scalars["String"] | null;
  __typename: "AuthorsItem";
};

export type AuthorsItemOrderByEnum =
  | "_sys_createdAt__ASC"
  | "_sys_createdAt__DESC"
  | "_sys_hash__ASC"
  | "_sys_hash__DESC"
  | "_sys_id__ASC"
  | "_sys_id__DESC"
  | "_sys_lastModifiedAt__ASC"
  | "_sys_lastModifiedAt__DESC"
  | "_sys_slug__ASC"
  | "_sys_slug__DESC"
  | "_sys_title__ASC"
  | "_sys_title__DESC"
  | "avatar__ASC"
  | "avatar__DESC"
  | "xUrl__ASC"
  | "xUrl__DESC";

export type BaseRichTextJson = {
  blocks: Scalars["String"];
  content: Scalars["BSHBRichTextContentSchema"];
  toc: Scalars["BSHBRichTextTOCSchema"];
  __typename: "BaseRichTextJson";
};

export type BlockAudio = {
  /** The duration of the audio in seconds. If the duration is not available, it will be estimated based on the file size. */
  duration: Scalars["Float"];
  fileName: Scalars["String"];
  fileSize: Scalars["Int"];
  lastModified: Scalars["Float"];
  mimeType: Scalars["String"];
  url: Scalars["String"];
  __typename: "BlockAudio";
};

export type BlockCodeSnippet = {
  allowedLanguages: Scalars["CodeSnippetLanguage"][];
  code: Scalars["String"];
  /** @deprecated Figuring out the correct api. */
  html: Scalars["String"];
  language: Scalars["CodeSnippetLanguage"];
  __typename: "BlockCodeSnippet";
};

export type BlockColor = {
  b: Scalars["Int"];
  g: Scalars["Int"];
  hex: Scalars["String"];
  hsl: Scalars["String"];
  r: Scalars["Int"];
  rgb: Scalars["String"];
  __typename: "BlockColor";
};

export type BlockDocument = (
  | Authors
  | AuthorsItem
  | Blog
  | Categories
  | CategoriesItem
  | LegalPages
  | LegalPagesItem
  | Posts
  | PostsItem
  | _AgentStart
  | authorsItem_AsList
  | categoriesItem_AsList
  | legalPagesItem_AsList
  | postsItem_AsList
) & { __isUnion?: true };

export type BlockDocumentSys = {
  apiNamePath: Scalars["String"];
  createdAt: Scalars["String"];
  hash: Scalars["String"];
  id: Scalars["ID"];
  idPath: Scalars["String"];
  lastModifiedAt: Scalars["String"];
  slug: Scalars["String"];
  slugPath: Scalars["String"];
  title: Scalars["String"];
  __typename: "BlockDocumentSys";
};

export type BlockFile = {
  fileName: Scalars["String"];
  fileSize: Scalars["Int"];
  lastModified: Scalars["Float"];
  mimeType: Scalars["String"];
  url: Scalars["String"];
  __typename: "BlockFile";
};

export type BlockImage = {
  alt: Scalars["String"] | null;
  aspectRatio: Scalars["String"];
  blurDataURL: Scalars["String"];
  fileName: Scalars["String"];
  fileSize: Scalars["Int"];
  height: Scalars["Int"];
  lastModified: Scalars["Float"];
  mimeType: Scalars["String"];
  /** @deprecated Renamed to `blurDataURL` to match Next.js Image's naming convention. */
  placeholderURL: Scalars["String"];
  /** @deprecated Use `url` instead. */
  rawUrl: Scalars["String"];
  thumbhash: Scalars["String"];
  /**
   * This field is used to generate the image URL with the provided options. The options are passed as arguments. For example, if you want to resize the image to 200x200 pixels, you can use the following query:
   *
   * ```graphql
   * {
   *   imageBlock {
   *     url(width: 200, height: 200)
   *   }
   * }
   * ```
   *
   * This will return the URL with the width and height set to 200 pixels.
   *
   * BaseHub uses Cloudflare for image resizing. Check out [all available options in their docs](https://developers.cloudflare.com/images/transform-images/transform-via-workers/#fetch-options).
   *
   */
  url: Scalars["String"];
  width: Scalars["Int"];
  __typename: "BlockImage";
};

export type BlockList = (
  | Authors
  | Categories
  | LegalPages
  | Posts
  | authorsItem_AsList
  | categoriesItem_AsList
  | legalPagesItem_AsList
  | postsItem_AsList
) & { __isUnion?: true };

export type BlockOgImage = {
  height: Scalars["Int"];
  url: Scalars["String"];
  width: Scalars["Int"];
  __typename: "BlockOgImage";
};

/** Rich text block */
export type BlockRichText = (Body | Body_1) & { __isUnion?: true };

export type BlockVideo = {
  aspectRatio: Scalars["String"];
  /** The duration of the video in seconds. If the duration is not available, it will be estimated based on the file size. */
  duration: Scalars["Float"];
  fileName: Scalars["String"];
  fileSize: Scalars["Int"];
  height: Scalars["Int"];
  lastModified: Scalars["Float"];
  mimeType: Scalars["String"];
  url: Scalars["String"];
  width: Scalars["Int"];
  __typename: "BlockVideo";
};

export type Blog = {
  _analyticsKey: Scalars["String"];
  _dashboardUrl: Scalars["String"];
  _id: Scalars["String"];
  _idPath: Scalars["String"];
  _slug: Scalars["String"];
  _slugPath: Scalars["String"];
  _sys: BlockDocumentSys;
  _title: Scalars["String"];
  authors: Authors;
  categories: Categories;
  posts: Posts;
  __typename: "Blog";
};

export type Body = {
  html: Scalars["String"];
  json: BodyRichText;
  markdown: Scalars["String"];
  plainText: Scalars["String"];
  readingTime: Scalars["Int"];
  __typename: "Body";
};

export type BodyRichText = {
  content: Scalars["BSHBRichTextContentSchema"];
  toc: Scalars["BSHBRichTextTOCSchema"];
  __typename: "BodyRichText";
};

export type Body_1 = {
  html: Scalars["String"];
  json: Body_1RichText;
  markdown: Scalars["String"];
  plainText: Scalars["String"];
  readingTime: Scalars["Int"];
  __typename: "Body_1";
};

export type Body_1RichText = {
  content: Scalars["BSHBRichTextContentSchema"];
  toc: Scalars["BSHBRichTextTOCSchema"];
  __typename: "Body_1RichText";
};

export type Categories = {
  _analyticsKey: Scalars["String"];
  _dashboardUrl: Scalars["String"];
  _id: Scalars["String"];
  _idPath: Scalars["String"];
  _meta: ListMeta;
  /** The key used to search from the frontend. */
  _searchKey: Scalars["String"];
  _slug: Scalars["String"];
  _slugPath: Scalars["String"];
  _sys: BlockDocumentSys;
  _title: Scalars["String"];
  /** Returns the first item in the list, or null if the list is empty. Useful when you expect only one result. */
  item: CategoriesItem | null;
  /** Returns the list of items after filtering and paginating according to the arguments sent by the client. */
  items: CategoriesItem[];
  __typename: "Categories";
};

export type CategoriesItem = {
  _analyticsKey: Scalars["String"];
  _dashboardUrl: Scalars["String"];
  /** Array of search highlight information with field names and HTML markup */
  _highlight: SearchHighlight[] | null;
  _id: Scalars["String"];
  _idPath: Scalars["String"];
  _slug: Scalars["String"];
  _slugPath: Scalars["String"];
  _sys: BlockDocumentSys;
  _title: Scalars["String"];
  __typename: "CategoriesItem";
};

export type CategoriesItemOrderByEnum =
  | "_sys_createdAt__ASC"
  | "_sys_createdAt__DESC"
  | "_sys_hash__ASC"
  | "_sys_hash__DESC"
  | "_sys_id__ASC"
  | "_sys_id__DESC"
  | "_sys_lastModifiedAt__ASC"
  | "_sys_lastModifiedAt__DESC"
  | "_sys_slug__ASC"
  | "_sys_slug__DESC"
  | "_sys_title__ASC"
  | "_sys_title__DESC";

export type GetUploadSignedURL = {
  signedURL: Scalars["String"];
  uploadURL: Scalars["String"];
  __typename: "GetUploadSignedURL";
};

export type LegalPages = {
  _analyticsKey: Scalars["String"];
  _dashboardUrl: Scalars["String"];
  _id: Scalars["String"];
  _idPath: Scalars["String"];
  _meta: ListMeta;
  /** The key used to search from the frontend. */
  _searchKey: Scalars["String"];
  _slug: Scalars["String"];
  _slugPath: Scalars["String"];
  _sys: BlockDocumentSys;
  _title: Scalars["String"];
  /** Returns the first item in the list, or null if the list is empty. Useful when you expect only one result. */
  item: LegalPagesItem | null;
  /** Returns the list of items after filtering and paginating according to the arguments sent by the client. */
  items: LegalPagesItem[];
  __typename: "LegalPages";
};

export type LegalPagesItem = {
  _analyticsKey: Scalars["String"];
  _dashboardUrl: Scalars["String"];
  /** Array of search highlight information with field names and HTML markup */
  _highlight: SearchHighlight[] | null;
  _id: Scalars["String"];
  _idPath: Scalars["String"];
  _slug: Scalars["String"];
  _slugPath: Scalars["String"];
  _sys: BlockDocumentSys;
  _title: Scalars["String"];
  body: Body_1;
  description: Scalars["String"];
  __typename: "LegalPagesItem";
};

export type LegalPagesItemOrderByEnum =
  | "_sys_createdAt__ASC"
  | "_sys_createdAt__DESC"
  | "_sys_hash__ASC"
  | "_sys_hash__DESC"
  | "_sys_id__ASC"
  | "_sys_id__DESC"
  | "_sys_lastModifiedAt__ASC"
  | "_sys_lastModifiedAt__DESC"
  | "_sys_slug__ASC"
  | "_sys_slug__DESC"
  | "_sys_title__ASC"
  | "_sys_title__DESC"
  | "body__ASC"
  | "body__DESC"
  | "description__ASC"
  | "description__DESC";

export type ListMeta = {
  /** Number of items after applying filters but before pagination */
  filteredCount: Scalars["Int"];
  /** Total number of items in collection before any filtering/pagination */
  totalCount: Scalars["Int"];
  __typename: "ListMeta";
};

export type MediaBlock = (BlockAudio | BlockFile | BlockImage | BlockVideo) & {
  __isUnion?: true;
};

export type MediaBlockUnion = (
  | BlockAudio
  | BlockFile
  | BlockImage
  | BlockVideo
) & { __isUnion?: true };

export type Mutation = {
  /**
   * Returns a signed url and an upload url so that you can upload files into your repository.
   *
   * Example usage with JavaScript:
   * ```js
   * async function handleUpload(file: File) {
   *   const { getUploadSignedURL } = await basehub().mutation({
   *     getUploadSignedURL: {
   *       __args: { fileName: file.name },
   *       signedURL: true,
   *       uploadURL: true,
   *     }
   *   })
   *
   *   const { signedURL, uploadURL } = getUploadSignedURL
   *
   *   await fetch(signedURL, { method: 'PUT', body: file })
   *
   *   // done! do something with the uploadURL now
   * }
   * ```
   *
   */
  getUploadSignedURL: GetUploadSignedURL;
  /** Start a job that can be awaited and the result given directly. Under the hood, it runs `transactionAsync` and polls for the result until it is available. You can pass a `timeout` argument, the default being 30_000ms. */
  transaction: TransactionStatus;
  /** Start an asynchronous job to mutate BaseHub data. Returns a transaction ID which you can use to get the result of the job. */
  transactionAsync: Scalars["String"];
  transactionStatus: TransactionStatus;
  __typename: "Mutation";
};

export type Posts = {
  _analyticsKey: Scalars["String"];
  _dashboardUrl: Scalars["String"];
  _id: Scalars["String"];
  _idPath: Scalars["String"];
  _meta: ListMeta;
  /** The key used to search from the frontend. */
  _searchKey: Scalars["String"];
  _slug: Scalars["String"];
  _slugPath: Scalars["String"];
  _sys: BlockDocumentSys;
  _title: Scalars["String"];
  /** Returns the first item in the list, or null if the list is empty. Useful when you expect only one result. */
  item: PostsItem | null;
  /** Returns the list of items after filtering and paginating according to the arguments sent by the client. */
  items: PostsItem[];
  __typename: "Posts";
};

export type PostsItem = {
  _analyticsKey: Scalars["String"];
  _dashboardUrl: Scalars["String"];
  /** Array of search highlight information with field names and HTML markup */
  _highlight: SearchHighlight[] | null;
  _id: Scalars["String"];
  _idPath: Scalars["String"];
  _slug: Scalars["String"];
  _slugPath: Scalars["String"];
  _sys: BlockDocumentSys;
  _title: Scalars["String"];
  authors: AuthorsItem[];
  body: Body;
  categories: CategoriesItem[] | null;
  /** ISO 8601 date string. */
  date: Scalars["String"];
  description: Scalars["String"];
  image: BlockImage;
  __typename: "PostsItem";
};

export type PostsItemOrderByEnum =
  | "_sys_createdAt__ASC"
  | "_sys_createdAt__DESC"
  | "_sys_hash__ASC"
  | "_sys_hash__DESC"
  | "_sys_id__ASC"
  | "_sys_id__DESC"
  | "_sys_lastModifiedAt__ASC"
  | "_sys_lastModifiedAt__DESC"
  | "_sys_slug__ASC"
  | "_sys_slug__DESC"
  | "_sys_title__ASC"
  | "_sys_title__DESC"
  | "authors__ASC"
  | "authors__DESC"
  | "body__ASC"
  | "body__DESC"
  | "categories__ASC"
  | "categories__DESC"
  | "date__ASC"
  | "date__DESC"
  | "description__ASC"
  | "description__DESC"
  | "image__ASC"
  | "image__DESC";

export type Query = {
  _agent: _AgentStart | null;
  /** Query across the custom AI agents in the repository. */
  _agents: _agents;
  /** Query across all of the instances of a component. Pass in filters and sorts if you want, and get each instance via the `items` key. */
  _componentInstances: _components;
  /** The diff between the current branch and the head commit. */
  _diff: Scalars["JSON"];
  /** The structure of the repository. Used by START. */
  _structure: Scalars["JSON"];
  _sys: RepoSys;
  blog: Blog;
  legalPages: LegalPages;
  __typename: "Query";
};

export type RepoSys = {
  branches: _Branches;
  dashboardUrl: Scalars["String"];
  forkUrl: Scalars["String"];
  hash: Scalars["String"];
  id: Scalars["ID"];
  playgroundInfo: _PlaygroundInfo | null;
  slug: Scalars["String"];
  title: Scalars["String"];
  __typename: "RepoSys";
};

export type RichTextJson = (
  | BaseRichTextJson
  | BodyRichText
  | Body_1RichText
) & { __isUnion?: true };

export type SearchHighlight = {
  /** The field/path that was matched (e.g., "title", "body.content") */
  by: Scalars["String"];
  /** HTML snippet with <mark> tags around the matched terms */
  snippet: Scalars["String"];
  __typename: "SearchHighlight";
};

export type TransactionStatus = {
  /** Duration in milliseconds. */
  duration: Scalars["Int"] | null;
  endedAt: Scalars["String"] | null;
  id: Scalars["String"];
  message: Scalars["String"] | null;
  startedAt: Scalars["String"];
  status: TransactionStatusEnum;
  __typename: "TransactionStatus";
};

export type TransactionStatusEnum =
  | "Cancelled"
  | "Completed"
  | "Failed"
  | "Running"
  | "Scheduled";

export type Variant = {
  apiName: Scalars["String"];
  color: Scalars["String"];
  id: Scalars["String"];
  isDefault: Scalars["Boolean"];
  label: Scalars["String"];
  __typename: "Variant";
};

export type _AgentStart = {
  _agentKey: Scalars["String"];
  _analyticsKey: Scalars["String"];
  _dashboardUrl: Scalars["String"];
  _id: Scalars["String"];
  _idPath: Scalars["String"];
  _slug: Scalars["String"];
  _slugPath: Scalars["String"];
  _sys: BlockDocumentSys;
  _title: Scalars["String"];
  accent: Scalars["String"];
  avatar: Scalars["String"];
  chatUrl: Scalars["String"];
  commit: Scalars["Boolean"];
  description: Scalars["String"];
  edit: Scalars["Boolean"];
  embedUrl: Scalars["String"];
  getUserInfo: Scalars["Boolean"];
  grayscale: Scalars["String"];
  manageBranches: Scalars["Boolean"];
  mcpUrl: Scalars["String"];
  model: Scalars["String"];
  openRouterKey: Scalars["String"] | null;
  searchTheWeb: Scalars["Boolean"];
  slackInstallUrl: Scalars["String"];
  systemPrompt: Scalars["String"];
  __typename: "_AgentStart";
};

export type _BranchInfo = {
  archivedAt: Scalars["String"] | null;
  archivedBy: Scalars["String"] | null;
  authorId: Scalars["String"] | null;
  contributors: Scalars["String"][] | null;
  createdAt: Scalars["String"];
  description: Scalars["String"] | null;
  git: _GitInfo | null;
  headCommit: _CommitInfo | null;
  headCommitId: Scalars["String"] | null;
  id: Scalars["ID"];
  inlineSuggestionAppliedAt: Scalars["String"] | null;
  isDefault: Scalars["Boolean"];
  isInlineSuggestion: Scalars["Boolean"] | null;
  name: Scalars["String"];
  playgroundId: Scalars["String"] | null;
  rollbackCommitId: Scalars["String"] | null;
  rollbackIsoDate: Scalars["String"] | null;
  sourceBranchId: Scalars["String"] | null;
  updatedAt: Scalars["String"] | null;
  workingRootBlockId: Scalars["String"] | null;
  __typename: "_BranchInfo";
};

export type _Branches = {
  _meta: ListMeta;
  items: _BranchInfo[];
  __typename: "_Branches";
};

export type _CommitInfo = {
  authorId: Scalars["String"];
  branchId: Scalars["String"];
  contributors: Scalars["String"][] | null;
  createdAt: Scalars["String"];
  hash: Scalars["String"];
  id: Scalars["String"];
  mergeParentCommitId: Scalars["String"] | null;
  message: Scalars["String"];
  parentCommitId: Scalars["String"] | null;
  /** Whether this commit is from a playground branch. */
  playgroundId: Scalars["String"] | null;
  repoId: Scalars["String"];
  rootBlockId: Scalars["String"];
  __typename: "_CommitInfo";
};

export type _GitInfo = {
  branch: Scalars["String"];
  deploymentUrl: Scalars["String"] | null;
  __typename: "_GitInfo";
};

export type _PlaygroundInfo = {
  claimUrl: Scalars["String"] | null;
  editUrl: Scalars["String"];
  expiresAt: Scalars["String"] | null;
  id: Scalars["String"] | null;
  __typename: "_PlaygroundInfo";
};

export type _ResolveTargetsWithEnum = "id" | "objectName";

export type _StructureFormatEnum = "json" | "xml";

export type _agents = {
  start: _AgentStart;
  __typename: "_agents";
};

export type _components = {
  authorsItem: authorsItem_AsList;
  categoriesItem: categoriesItem_AsList;
  legalPagesItem: legalPagesItem_AsList;
  postsItem: postsItem_AsList;
  __typename: "_components";
};

export type authorsItem_AsList = {
  _analyticsKey: Scalars["String"];
  _dashboardUrl: Scalars["String"];
  _id: Scalars["String"];
  _idPath: Scalars["String"];
  _meta: ListMeta;
  /** The key used to search from the frontend. */
  _searchKey: Scalars["String"];
  _slug: Scalars["String"];
  _slugPath: Scalars["String"];
  _sys: BlockDocumentSys;
  _title: Scalars["String"];
  /** Returns the first item in the list, or null if the list is empty. Useful when you expect only one result. */
  item: AuthorsItem | null;
  /** Returns the list of items after filtering and paginating according to the arguments sent by the client. */
  items: AuthorsItem[];
  __typename: "authorsItem_AsList";
};

export type categoriesItem_AsList = {
  _analyticsKey: Scalars["String"];
  _dashboardUrl: Scalars["String"];
  _id: Scalars["String"];
  _idPath: Scalars["String"];
  _meta: ListMeta;
  /** The key used to search from the frontend. */
  _searchKey: Scalars["String"];
  _slug: Scalars["String"];
  _slugPath: Scalars["String"];
  _sys: BlockDocumentSys;
  _title: Scalars["String"];
  /** Returns the first item in the list, or null if the list is empty. Useful when you expect only one result. */
  item: CategoriesItem | null;
  /** Returns the list of items after filtering and paginating according to the arguments sent by the client. */
  items: CategoriesItem[];
  __typename: "categoriesItem_AsList";
};

export type legalPagesItem_AsList = {
  _analyticsKey: Scalars["String"];
  _dashboardUrl: Scalars["String"];
  _id: Scalars["String"];
  _idPath: Scalars["String"];
  _meta: ListMeta;
  /** The key used to search from the frontend. */
  _searchKey: Scalars["String"];
  _slug: Scalars["String"];
  _slugPath: Scalars["String"];
  _sys: BlockDocumentSys;
  _title: Scalars["String"];
  /** Returns the first item in the list, or null if the list is empty. Useful when you expect only one result. */
  item: LegalPagesItem | null;
  /** Returns the list of items after filtering and paginating according to the arguments sent by the client. */
  items: LegalPagesItem[];
  __typename: "legalPagesItem_AsList";
};

export type postsItem_AsList = {
  _analyticsKey: Scalars["String"];
  _dashboardUrl: Scalars["String"];
  _id: Scalars["String"];
  _idPath: Scalars["String"];
  _meta: ListMeta;
  /** The key used to search from the frontend. */
  _searchKey: Scalars["String"];
  _slug: Scalars["String"];
  _slugPath: Scalars["String"];
  _sys: BlockDocumentSys;
  _title: Scalars["String"];
  /** Returns the first item in the list, or null if the list is empty. Useful when you expect only one result. */
  item: PostsItem | null;
  /** Returns the list of items after filtering and paginating according to the arguments sent by the client. */
  items: PostsItem[];
  __typename: "postsItem_AsList";
};

export type AuthorsGenqlSelection = {
  _analyticsKey?:
    | {
        __args: {
          /**
           * The scope of the analytics key. Use `send` for just ingesting data. Use `query` if you need to show an analytics data in your website.
           *
           * Have in mind, if you expose your `query` analytics key in the frontend, you'll be exposing all of this block's analytics data to the public. This is generally safe, but it might not be in your case.
           */
          scope?: AnalyticsKeyScope | null;
        };
      }
    | boolean
    | number;
  _dashboardUrl?: boolean | number;
  _id?: boolean | number;
  _idPath?: boolean | number;
  _meta?: ListMetaGenqlSelection;
  /** The key used to search from the frontend. */
  _searchKey?: boolean | number;
  _slug?: boolean | number;
  _slugPath?: boolean | number;
  _sys?: BlockDocumentSysGenqlSelection;
  _title?: boolean | number;
  /** Returns the first item in the list, or null if the list is empty. Useful when you expect only one result. */
  item?: AuthorsItemGenqlSelection;
  /** Returns the list of items after filtering and paginating according to the arguments sent by the client. */
  items?: AuthorsItemGenqlSelection;
  __typename?: boolean | number;
  __fragmentOn?: "Authors";
};

export type AuthorsItemGenqlSelection = {
  _analyticsKey?:
    | {
        __args: {
          /**
           * The scope of the analytics key. Use `send` for just ingesting data. Use `query` if you need to show an analytics data in your website.
           *
           * Have in mind, if you expose your `query` analytics key in the frontend, you'll be exposing all of this block's analytics data to the public. This is generally safe, but it might not be in your case.
           */
          scope?: AnalyticsKeyScope | null;
        };
      }
    | boolean
    | number;
  _dashboardUrl?: boolean | number;
  /** Array of search highlight information with field names and HTML markup */
  _highlight?: SearchHighlightGenqlSelection;
  _id?: boolean | number;
  _idPath?: boolean | number;
  _slug?: boolean | number;
  _slugPath?: boolean | number;
  _sys?: BlockDocumentSysGenqlSelection;
  _title?: boolean | number;
  avatar?: BlockImageGenqlSelection;
  xUrl?: boolean | number;
  __typename?: boolean | number;
  __fragmentOn?: "AuthorsItem";
};

export type AuthorsItemFilterInput = {
  AND?: AuthorsItemFilterInput | null;
  OR?: AuthorsItemFilterInput | null;
  _id?: StringFilter | null;
  _slug?: StringFilter | null;
  _sys_apiNamePath?: StringFilter | null;
  _sys_createdAt?: DateFilter | null;
  _sys_hash?: StringFilter | null;
  _sys_id?: StringFilter | null;
  _sys_idPath?: StringFilter | null;
  _sys_lastModifiedAt?: DateFilter | null;
  _sys_slug?: StringFilter | null;
  _sys_slugPath?: StringFilter | null;
  _sys_title?: StringFilter | null;
  _title?: StringFilter | null;
  xUrl?: StringFilter | null;
};

export type AuthorsItemSearchInput = {
  /** Searchable fields for query */
  by?: Scalars["String"][] | null;
  /** Search query */
  q?: Scalars["String"] | null;
};

export type BaseRichTextJsonGenqlSelection = {
  blocks?: boolean | number;
  content?: boolean | number;
  toc?: boolean | number;
  __typename?: boolean | number;
  __fragmentOn?: "BaseRichTextJson";
};

export type BlockAudioGenqlSelection = {
  /** The duration of the audio in seconds. If the duration is not available, it will be estimated based on the file size. */
  duration?: boolean | number;
  fileName?: boolean | number;
  fileSize?: boolean | number;
  lastModified?: boolean | number;
  mimeType?: boolean | number;
  url?: boolean | number;
  __typename?: boolean | number;
  __fragmentOn?: "BlockAudio";
};

export type BlockCodeSnippetGenqlSelection = {
  allowedLanguages?: boolean | number;
  code?: boolean | number;
  /** @deprecated Figuring out the correct api. */
  html?:
    | {
        __args: {
          /** Theme for the code snippet */
          theme?: Scalars["String"] | null;
        };
      }
    | boolean
    | number;
  language?: boolean | number;
  __typename?: boolean | number;
  __fragmentOn?: "BlockCodeSnippet";
};

export type BlockColorGenqlSelection = {
  b?: boolean | number;
  g?: boolean | number;
  hex?: boolean | number;
  hsl?: boolean | number;
  r?: boolean | number;
  rgb?: boolean | number;
  __typename?: boolean | number;
  __fragmentOn?: "BlockColor";
};

export type BlockDocumentGenqlSelection = {
  _analyticsKey?:
    | {
        __args: {
          /**
           * The scope of the analytics key. Use `send` for just ingesting data. Use `query` if you need to show an analytics data in your website.
           *
           * Have in mind, if you expose your `query` analytics key in the frontend, you'll be exposing all of this block's analytics data to the public. This is generally safe, but it might not be in your case.
           */
          scope?: AnalyticsKeyScope | null;
        };
      }
    | boolean
    | number;
  _dashboardUrl?: boolean | number;
  _id?: boolean | number;
  _idPath?: boolean | number;
  _slug?: boolean | number;
  _slugPath?: boolean | number;
  _sys?: BlockDocumentSysGenqlSelection;
  _title?: boolean | number;
  on_Authors?: AuthorsGenqlSelection;
  on_AuthorsItem?: AuthorsItemGenqlSelection;
  on_Blog?: BlogGenqlSelection;
  on_Categories?: CategoriesGenqlSelection;
  on_CategoriesItem?: CategoriesItemGenqlSelection;
  on_LegalPages?: LegalPagesGenqlSelection;
  on_LegalPagesItem?: LegalPagesItemGenqlSelection;
  on_Posts?: PostsGenqlSelection;
  on_PostsItem?: PostsItemGenqlSelection;
  on__AgentStart?: _AgentStartGenqlSelection;
  on_authorsItem_AsList?: authorsItem_AsListGenqlSelection;
  on_categoriesItem_AsList?: categoriesItem_AsListGenqlSelection;
  on_legalPagesItem_AsList?: legalPagesItem_AsListGenqlSelection;
  on_postsItem_AsList?: postsItem_AsListGenqlSelection;
  __typename?: boolean | number;
  __fragmentOn?: "BlockDocument";
};

export type BlockDocumentSysGenqlSelection = {
  apiNamePath?: boolean | number;
  createdAt?: boolean | number;
  hash?: boolean | number;
  id?: boolean | number;
  idPath?: boolean | number;
  lastModifiedAt?: boolean | number;
  slug?: boolean | number;
  slugPath?: boolean | number;
  title?: boolean | number;
  __typename?: boolean | number;
  __fragmentOn?: "BlockDocumentSys";
};

export type BlockFileGenqlSelection = {
  fileName?: boolean | number;
  fileSize?: boolean | number;
  lastModified?: boolean | number;
  mimeType?: boolean | number;
  url?: boolean | number;
  __typename?: boolean | number;
  __fragmentOn?: "BlockFile";
};

export type BlockImageGenqlSelection = {
  alt?: boolean | number;
  aspectRatio?: boolean | number;
  blurDataURL?: boolean | number;
  fileName?: boolean | number;
  fileSize?: boolean | number;
  height?: boolean | number;
  lastModified?: boolean | number;
  mimeType?: boolean | number;
  /** @deprecated Renamed to `blurDataURL` to match Next.js Image's naming convention. */
  placeholderURL?: boolean | number;
  /** @deprecated Use `url` instead. */
  rawUrl?: boolean | number;
  thumbhash?: boolean | number;
  /**
   * This field is used to generate the image URL with the provided options. The options are passed as arguments. For example, if you want to resize the image to 200x200 pixels, you can use the following query:
   *
   * ```graphql
   * {
   *   imageBlock {
   *     url(width: 200, height: 200)
   *   }
   * }
   * ```
   *
   * This will return the URL with the width and height set to 200 pixels.
   *
   * BaseHub uses Cloudflare for image resizing. Check out [all available options in their docs](https://developers.cloudflare.com/images/transform-images/transform-via-workers/#fetch-options).
   *
   */
  url?:
    | {
        __args: {
          anim?: Scalars["String"] | null;
          background?: Scalars["String"] | null;
          blur?: Scalars["Int"] | null;
          border?: Scalars["String"] | null;
          brightness?: Scalars["Int"] | null;
          compression?: Scalars["String"] | null;
          contrast?: Scalars["Int"] | null;
          dpr?: Scalars["Int"] | null;
          fit?: Scalars["String"] | null;
          format?: Scalars["String"] | null;
          gamma?: Scalars["String"] | null;
          gravity?: Scalars["String"] | null;
          height?: Scalars["Int"] | null;
          metadata?: Scalars["String"] | null;
          quality?: Scalars["Int"] | null;
          rotate?: Scalars["String"] | null;
          sharpen?: Scalars["String"] | null;
          trim?: Scalars["String"] | null;
          width?: Scalars["Int"] | null;
        };
      }
    | boolean
    | number;
  width?: boolean | number;
  __typename?: boolean | number;
  __fragmentOn?: "BlockImage";
};

export type BlockListGenqlSelection = {
  _analyticsKey?:
    | {
        __args: {
          /**
           * The scope of the analytics key. Use `send` for just ingesting data. Use `query` if you need to show an analytics data in your website.
           *
           * Have in mind, if you expose your `query` analytics key in the frontend, you'll be exposing all of this block's analytics data to the public. This is generally safe, but it might not be in your case.
           */
          scope?: AnalyticsKeyScope | null;
        };
      }
    | boolean
    | number;
  _dashboardUrl?: boolean | number;
  _id?: boolean | number;
  _idPath?: boolean | number;
  _meta?: ListMetaGenqlSelection;
  /** The key used to search from the frontend. */
  _searchKey?: boolean | number;
  _slug?: boolean | number;
  _slugPath?: boolean | number;
  _sys?: BlockDocumentSysGenqlSelection;
  _title?: boolean | number;
  on_Authors?: AuthorsGenqlSelection;
  on_Categories?: CategoriesGenqlSelection;
  on_LegalPages?: LegalPagesGenqlSelection;
  on_Posts?: PostsGenqlSelection;
  on_authorsItem_AsList?: authorsItem_AsListGenqlSelection;
  on_categoriesItem_AsList?: categoriesItem_AsListGenqlSelection;
  on_legalPagesItem_AsList?: legalPagesItem_AsListGenqlSelection;
  on_postsItem_AsList?: postsItem_AsListGenqlSelection;
  __typename?: boolean | number;
  __fragmentOn?: "BlockList";
};

export type BlockOgImageGenqlSelection = {
  height?: boolean | number;
  url?: boolean | number;
  width?: boolean | number;
  __typename?: boolean | number;
  __fragmentOn?: "BlockOgImage";
};

/** Rich text block */
export type BlockRichTextGenqlSelection = {
  html?:
    | {
        __args: {
          /** It automatically generates a unique id for each heading present in the HTML. Enabled by default. */
          slugs?: Scalars["Boolean"] | null;
          /** Inserts a table of contents at the beginning of the HTML. */
          toc?: Scalars["Boolean"] | null;
        };
      }
    | boolean
    | number;
  json?: RichTextJsonGenqlSelection;
  markdown?: boolean | number;
  plainText?: boolean | number;
  readingTime?:
    | {
        __args: {
          /** Words per minute, defaults to average 183wpm */
          wpm?: Scalars["Int"] | null;
        };
      }
    | boolean
    | number;
  on_Body?: BodyGenqlSelection;
  on_Body_1?: Body_1GenqlSelection;
  __typename?: boolean | number;
  __fragmentOn?: "BlockRichText";
};

export type BlockVideoGenqlSelection = {
  aspectRatio?: boolean | number;
  /** The duration of the video in seconds. If the duration is not available, it will be estimated based on the file size. */
  duration?: boolean | number;
  fileName?: boolean | number;
  fileSize?: boolean | number;
  height?: boolean | number;
  lastModified?: boolean | number;
  mimeType?: boolean | number;
  url?: boolean | number;
  width?: boolean | number;
  __typename?: boolean | number;
  __fragmentOn?: "BlockVideo";
};

export type BlogGenqlSelection = {
  _analyticsKey?:
    | {
        __args: {
          /**
           * The scope of the analytics key. Use `send` for just ingesting data. Use `query` if you need to show an analytics data in your website.
           *
           * Have in mind, if you expose your `query` analytics key in the frontend, you'll be exposing all of this block's analytics data to the public. This is generally safe, but it might not be in your case.
           */
          scope?: AnalyticsKeyScope | null;
        };
      }
    | boolean
    | number;
  _dashboardUrl?: boolean | number;
  _id?: boolean | number;
  _idPath?: boolean | number;
  _slug?: boolean | number;
  _slugPath?: boolean | number;
  _sys?: BlockDocumentSysGenqlSelection;
  _title?: boolean | number;
  authors?: AuthorsGenqlSelection & {
    __args?: {
      /** Filter by a field. */
      filter?: AuthorsItemFilterInput | null;
      /** Limit the number of items returned. Defaults to 500. */
      first?: Scalars["Int"] | null;
      /** Order by a field. */
      orderBy?: AuthorsItemOrderByEnum | null;
      /** Search configuration */
      search?: AuthorsItemSearchInput | null;
      /** Skip the first n items. */
      skip?: Scalars["Int"] | null;
    };
  };
  categories?: CategoriesGenqlSelection & {
    __args?: {
      /** Filter by a field. */
      filter?: CategoriesItemFilterInput | null;
      /** Limit the number of items returned. Defaults to 500. */
      first?: Scalars["Int"] | null;
      /** Order by a field. */
      orderBy?: CategoriesItemOrderByEnum | null;
      /** Search configuration */
      search?: CategoriesItemSearchInput | null;
      /** Skip the first n items. */
      skip?: Scalars["Int"] | null;
    };
  };
  posts?: PostsGenqlSelection & {
    __args?: {
      /** Filter by a field. */
      filter?: PostsItemFilterInput | null;
      /** Limit the number of items returned. Defaults to 500. */
      first?: Scalars["Int"] | null;
      /** Order by a field. */
      orderBy?: PostsItemOrderByEnum | null;
      /** Search configuration */
      search?: PostsItemSearchInput | null;
      /** Skip the first n items. */
      skip?: Scalars["Int"] | null;
    };
  };
  __typename?: boolean | number;
  __fragmentOn?: "Blog";
};

export type BodyGenqlSelection = {
  html?:
    | {
        __args: {
          /** It automatically generates a unique id for each heading present in the HTML. Enabled by default. */
          slugs?: Scalars["Boolean"] | null;
          /** Inserts a table of contents at the beginning of the HTML. */
          toc?: Scalars["Boolean"] | null;
        };
      }
    | boolean
    | number;
  json?: BodyRichTextGenqlSelection;
  markdown?: boolean | number;
  plainText?: boolean | number;
  readingTime?:
    | {
        __args: {
          /** Words per minute, defaults to average 183wpm */
          wpm?: Scalars["Int"] | null;
        };
      }
    | boolean
    | number;
  __typename?: boolean | number;
  __fragmentOn?: "Body";
};

export type BodyRichTextGenqlSelection = {
  content?: boolean | number;
  toc?: boolean | number;
  __typename?: boolean | number;
  __fragmentOn?: "BodyRichText";
};

export type Body_1GenqlSelection = {
  html?:
    | {
        __args: {
          /** It automatically generates a unique id for each heading present in the HTML. Enabled by default. */
          slugs?: Scalars["Boolean"] | null;
          /** Inserts a table of contents at the beginning of the HTML. */
          toc?: Scalars["Boolean"] | null;
        };
      }
    | boolean
    | number;
  json?: Body_1RichTextGenqlSelection;
  markdown?: boolean | number;
  plainText?: boolean | number;
  readingTime?:
    | {
        __args: {
          /** Words per minute, defaults to average 183wpm */
          wpm?: Scalars["Int"] | null;
        };
      }
    | boolean
    | number;
  __typename?: boolean | number;
  __fragmentOn?: "Body_1";
};

export type Body_1RichTextGenqlSelection = {
  content?: boolean | number;
  toc?: boolean | number;
  __typename?: boolean | number;
  __fragmentOn?: "Body_1RichText";
};

export type CategoriesGenqlSelection = {
  _analyticsKey?:
    | {
        __args: {
          /**
           * The scope of the analytics key. Use `send` for just ingesting data. Use `query` if you need to show an analytics data in your website.
           *
           * Have in mind, if you expose your `query` analytics key in the frontend, you'll be exposing all of this block's analytics data to the public. This is generally safe, but it might not be in your case.
           */
          scope?: AnalyticsKeyScope | null;
        };
      }
    | boolean
    | number;
  _dashboardUrl?: boolean | number;
  _id?: boolean | number;
  _idPath?: boolean | number;
  _meta?: ListMetaGenqlSelection;
  /** The key used to search from the frontend. */
  _searchKey?: boolean | number;
  _slug?: boolean | number;
  _slugPath?: boolean | number;
  _sys?: BlockDocumentSysGenqlSelection;
  _title?: boolean | number;
  /** Returns the first item in the list, or null if the list is empty. Useful when you expect only one result. */
  item?: CategoriesItemGenqlSelection;
  /** Returns the list of items after filtering and paginating according to the arguments sent by the client. */
  items?: CategoriesItemGenqlSelection;
  __typename?: boolean | number;
  __fragmentOn?: "Categories";
};

export type CategoriesItemGenqlSelection = {
  _analyticsKey?:
    | {
        __args: {
          /**
           * The scope of the analytics key. Use `send` for just ingesting data. Use `query` if you need to show an analytics data in your website.
           *
           * Have in mind, if you expose your `query` analytics key in the frontend, you'll be exposing all of this block's analytics data to the public. This is generally safe, but it might not be in your case.
           */
          scope?: AnalyticsKeyScope | null;
        };
      }
    | boolean
    | number;
  _dashboardUrl?: boolean | number;
  /** Array of search highlight information with field names and HTML markup */
  _highlight?: SearchHighlightGenqlSelection;
  _id?: boolean | number;
  _idPath?: boolean | number;
  _slug?: boolean | number;
  _slugPath?: boolean | number;
  _sys?: BlockDocumentSysGenqlSelection;
  _title?: boolean | number;
  __typename?: boolean | number;
  __fragmentOn?: "CategoriesItem";
};

export type CategoriesItemFilterInput = {
  AND?: CategoriesItemFilterInput | null;
  OR?: CategoriesItemFilterInput | null;
  _id?: StringFilter | null;
  _slug?: StringFilter | null;
  _sys_apiNamePath?: StringFilter | null;
  _sys_createdAt?: DateFilter | null;
  _sys_hash?: StringFilter | null;
  _sys_id?: StringFilter | null;
  _sys_idPath?: StringFilter | null;
  _sys_lastModifiedAt?: DateFilter | null;
  _sys_slug?: StringFilter | null;
  _sys_slugPath?: StringFilter | null;
  _sys_title?: StringFilter | null;
  _title?: StringFilter | null;
};

export type CategoriesItemSearchInput = {
  /** Searchable fields for query */
  by?: Scalars["String"][] | null;
  /** Search query */
  q?: Scalars["String"] | null;
};

export type DateFilter = {
  eq?: Scalars["DateTime"] | null;
  isAfter?: Scalars["DateTime"] | null;
  isBefore?: Scalars["DateTime"] | null;
  isNull?: Scalars["Boolean"] | null;
  neq?: Scalars["DateTime"] | null;
  onOrAfter?: Scalars["DateTime"] | null;
  onOrBefore?: Scalars["DateTime"] | null;
};

export type GetUploadSignedURLGenqlSelection = {
  signedURL?: boolean | number;
  uploadURL?: boolean | number;
  __typename?: boolean | number;
  __fragmentOn?: "GetUploadSignedURL";
};

export type LegalPagesGenqlSelection = {
  _analyticsKey?:
    | {
        __args: {
          /**
           * The scope of the analytics key. Use `send` for just ingesting data. Use `query` if you need to show an analytics data in your website.
           *
           * Have in mind, if you expose your `query` analytics key in the frontend, you'll be exposing all of this block's analytics data to the public. This is generally safe, but it might not be in your case.
           */
          scope?: AnalyticsKeyScope | null;
        };
      }
    | boolean
    | number;
  _dashboardUrl?: boolean | number;
  _id?: boolean | number;
  _idPath?: boolean | number;
  _meta?: ListMetaGenqlSelection;
  /** The key used to search from the frontend. */
  _searchKey?: boolean | number;
  _slug?: boolean | number;
  _slugPath?: boolean | number;
  _sys?: BlockDocumentSysGenqlSelection;
  _title?: boolean | number;
  /** Returns the first item in the list, or null if the list is empty. Useful when you expect only one result. */
  item?: LegalPagesItemGenqlSelection;
  /** Returns the list of items after filtering and paginating according to the arguments sent by the client. */
  items?: LegalPagesItemGenqlSelection;
  __typename?: boolean | number;
  __fragmentOn?: "LegalPages";
};

export type LegalPagesItemGenqlSelection = {
  _analyticsKey?:
    | {
        __args: {
          /**
           * The scope of the analytics key. Use `send` for just ingesting data. Use `query` if you need to show an analytics data in your website.
           *
           * Have in mind, if you expose your `query` analytics key in the frontend, you'll be exposing all of this block's analytics data to the public. This is generally safe, but it might not be in your case.
           */
          scope?: AnalyticsKeyScope | null;
        };
      }
    | boolean
    | number;
  _dashboardUrl?: boolean | number;
  /** Array of search highlight information with field names and HTML markup */
  _highlight?: SearchHighlightGenqlSelection;
  _id?: boolean | number;
  _idPath?: boolean | number;
  _slug?: boolean | number;
  _slugPath?: boolean | number;
  _sys?: BlockDocumentSysGenqlSelection;
  _title?: boolean | number;
  body?: Body_1GenqlSelection;
  description?: boolean | number;
  __typename?: boolean | number;
  __fragmentOn?: "LegalPagesItem";
};

export type LegalPagesItemFilterInput = {
  AND?: LegalPagesItemFilterInput | null;
  OR?: LegalPagesItemFilterInput | null;
  _id?: StringFilter | null;
  _slug?: StringFilter | null;
  _sys_apiNamePath?: StringFilter | null;
  _sys_createdAt?: DateFilter | null;
  _sys_hash?: StringFilter | null;
  _sys_id?: StringFilter | null;
  _sys_idPath?: StringFilter | null;
  _sys_lastModifiedAt?: DateFilter | null;
  _sys_slug?: StringFilter | null;
  _sys_slugPath?: StringFilter | null;
  _sys_title?: StringFilter | null;
  _title?: StringFilter | null;
  description?: StringFilter | null;
};

export type LegalPagesItemSearchInput = {
  /** Searchable fields for query */
  by?: Scalars["String"][] | null;
  /** Search query */
  q?: Scalars["String"] | null;
};

export type ListFilter = {
  isEmpty?: Scalars["Boolean"] | null;
  length?: Scalars["Int"] | null;
};

export type ListMetaGenqlSelection = {
  /** Number of items after applying filters but before pagination */
  filteredCount?: boolean | number;
  /** Total number of items in collection before any filtering/pagination */
  totalCount?: boolean | number;
  __typename?: boolean | number;
  __fragmentOn?: "ListMeta";
};

export type MediaBlockGenqlSelection = {
  fileName?: boolean | number;
  fileSize?: boolean | number;
  lastModified?: boolean | number;
  mimeType?: boolean | number;
  url?: boolean | number;
  on_BlockAudio?: BlockAudioGenqlSelection;
  on_BlockFile?: BlockFileGenqlSelection;
  on_BlockImage?: BlockImageGenqlSelection;
  on_BlockVideo?: BlockVideoGenqlSelection;
  __typename?: boolean | number;
  __fragmentOn?: "MediaBlock";
};

export type MediaBlockUnionGenqlSelection = {
  on_BlockAudio?: BlockAudioGenqlSelection;
  on_BlockFile?: BlockFileGenqlSelection;
  on_BlockImage?: BlockImageGenqlSelection;
  on_BlockVideo?: BlockVideoGenqlSelection;
  on_MediaBlock?: MediaBlockGenqlSelection;
  __typename?: boolean | number;
  __fragmentOn?: "MediaBlockUnion";
};

export type MutationGenqlSelection = {
  /**
   * Returns a signed url and an upload url so that you can upload files into your repository.
   *
   * Example usage with JavaScript:
   * ```js
   * async function handleUpload(file: File) {
   *   const { getUploadSignedURL } = await basehub().mutation({
   *     getUploadSignedURL: {
   *       __args: { fileName: file.name },
   *       signedURL: true,
   *       uploadURL: true,
   *     }
   *   })
   *
   *   const { signedURL, uploadURL } = getUploadSignedURL
   *
   *   await fetch(signedURL, { method: 'PUT', body: file })
   *
   *   // done! do something with the uploadURL now
   * }
   * ```
   *
   */
  getUploadSignedURL?: GetUploadSignedURLGenqlSelection & {
    __args: {
      /** SHA256 hash of the file. Used for reusing existing files. */
      fileHash?: Scalars["String"] | null;
      /** The file name */
      fileName: Scalars["String"];
    };
  };
  /** Start a job that can be awaited and the result given directly. Under the hood, it runs `transactionAsync` and polls for the result until it is available. You can pass a `timeout` argument, the default being 30_000ms. */
  transaction?: TransactionStatusGenqlSelection & {
    __args: {
      /** The ID of the author of the transaction. If not provided, the API Token will be used. */
      authorId?: Scalars["String"] | null;
      /** Auto make a commit in your Repo with the specified message. */
      autoCommit?: Scalars["String"] | null;
      /** Transaction data. */
      data: Transaction | Scalars["String"];
      /** Skip running workflows and event subscribers. Defaults to false. */
      skipWorkflows?: Scalars["Boolean"] | null;
      /** Timeout in milliseconds. */
      timeout?: Scalars["Int"] | null;
    };
  };
  /** Start an asynchronous job to mutate BaseHub data. Returns a transaction ID which you can use to get the result of the job. */
  transactionAsync?: {
    __args: {
      /** The ID of the author of the transaction. If not provided, the API Token will be used. */
      authorId?: Scalars["String"] | null;
      /** Auto make a commit in your Repo with the specified message. */
      autoCommit?: Scalars["String"] | null;
      /** Transaction data. */
      data: Scalars["String"];
      /** Skip running workflows and event subscribers. Defaults to false. */
      skipWorkflows?: Scalars["Boolean"] | null;
    };
  };
  transactionStatus?: TransactionStatusGenqlSelection & {
    __args: {
      /** Transaction ID */
      id: Scalars["String"];
    };
  };
  __typename?: boolean | number;
  __fragmentOn?: "Mutation";
};

export type NumberFilter = {
  eq?: Scalars["Float"] | null;
  gt?: Scalars["Float"] | null;
  gte?: Scalars["Float"] | null;
  isNull?: Scalars["Boolean"] | null;
  lt?: Scalars["Float"] | null;
  lte?: Scalars["Float"] | null;
  neq?: Scalars["Float"] | null;
};

export type PostsGenqlSelection = {
  _analyticsKey?:
    | {
        __args: {
          /**
           * The scope of the analytics key. Use `send` for just ingesting data. Use `query` if you need to show an analytics data in your website.
           *
           * Have in mind, if you expose your `query` analytics key in the frontend, you'll be exposing all of this block's analytics data to the public. This is generally safe, but it might not be in your case.
           */
          scope?: AnalyticsKeyScope | null;
        };
      }
    | boolean
    | number;
  _dashboardUrl?: boolean | number;
  _id?: boolean | number;
  _idPath?: boolean | number;
  _meta?: ListMetaGenqlSelection;
  /** The key used to search from the frontend. */
  _searchKey?: boolean | number;
  _slug?: boolean | number;
  _slugPath?: boolean | number;
  _sys?: BlockDocumentSysGenqlSelection;
  _title?: boolean | number;
  /** Returns the first item in the list, or null if the list is empty. Useful when you expect only one result. */
  item?: PostsItemGenqlSelection;
  /** Returns the list of items after filtering and paginating according to the arguments sent by the client. */
  items?: PostsItemGenqlSelection;
  __typename?: boolean | number;
  __fragmentOn?: "Posts";
};

export type PostsItemGenqlSelection = {
  _analyticsKey?:
    | {
        __args: {
          /**
           * The scope of the analytics key. Use `send` for just ingesting data. Use `query` if you need to show an analytics data in your website.
           *
           * Have in mind, if you expose your `query` analytics key in the frontend, you'll be exposing all of this block's analytics data to the public. This is generally safe, but it might not be in your case.
           */
          scope?: AnalyticsKeyScope | null;
        };
      }
    | boolean
    | number;
  _dashboardUrl?: boolean | number;
  /** Array of search highlight information with field names and HTML markup */
  _highlight?: SearchHighlightGenqlSelection;
  _id?: boolean | number;
  _idPath?: boolean | number;
  _slug?: boolean | number;
  _slugPath?: boolean | number;
  _sys?: BlockDocumentSysGenqlSelection;
  _title?: boolean | number;
  authors?: AuthorsItemGenqlSelection;
  body?: BodyGenqlSelection;
  categories?: CategoriesItemGenqlSelection;
  /** ISO 8601 date string. */
  date?: boolean | number;
  description?: boolean | number;
  image?: BlockImageGenqlSelection;
  __typename?: boolean | number;
  __fragmentOn?: "PostsItem";
};

export type PostsItemFilterInput = {
  AND?: PostsItemFilterInput | null;
  OR?: PostsItemFilterInput | null;
  _id?: StringFilter | null;
  _slug?: StringFilter | null;
  _sys_apiNamePath?: StringFilter | null;
  _sys_createdAt?: DateFilter | null;
  _sys_hash?: StringFilter | null;
  _sys_id?: StringFilter | null;
  _sys_idPath?: StringFilter | null;
  _sys_lastModifiedAt?: DateFilter | null;
  _sys_slug?: StringFilter | null;
  _sys_slugPath?: StringFilter | null;
  _sys_title?: StringFilter | null;
  _title?: StringFilter | null;
  authors?: PostsItemFilterInput__authors_0___untitled | null;
  categories?: PostsItemFilterInput__categories_0___untitled | null;
  date?: DateFilter | null;
  description?: StringFilter | null;
};

export type PostsItemFilterInput__authors_0___untitled = {
  _id?: StringFilter | null;
  _slug?: StringFilter | null;
  _sys_apiNamePath?: StringFilter | null;
  _sys_createdAt?: DateFilter | null;
  _sys_hash?: StringFilter | null;
  _sys_id?: StringFilter | null;
  _sys_idPath?: StringFilter | null;
  _sys_lastModifiedAt?: DateFilter | null;
  _sys_slug?: StringFilter | null;
  _sys_slugPath?: StringFilter | null;
  _sys_title?: StringFilter | null;
  _title?: StringFilter | null;
  xUrl?: StringFilter | null;
};

export type PostsItemFilterInput__categories_0___untitled = {
  _id?: StringFilter | null;
  _slug?: StringFilter | null;
  _sys_apiNamePath?: StringFilter | null;
  _sys_createdAt?: DateFilter | null;
  _sys_hash?: StringFilter | null;
  _sys_id?: StringFilter | null;
  _sys_idPath?: StringFilter | null;
  _sys_lastModifiedAt?: DateFilter | null;
  _sys_slug?: StringFilter | null;
  _sys_slugPath?: StringFilter | null;
  _sys_title?: StringFilter | null;
  _title?: StringFilter | null;
};

export type PostsItemSearchInput = {
  /** Searchable fields for query */
  by?: Scalars["String"][] | null;
  /** Search query */
  q?: Scalars["String"] | null;
};

export type QueryGenqlSelection = {
  _agent?: _AgentStartGenqlSelection & {
    __args: {
      /** The ID of the agent. */
      id: Scalars["String"];
    };
  };
  /** Query across the custom AI agents in the repository. */
  _agents?: _agentsGenqlSelection;
  /** Query across all of the instances of a component. Pass in filters and sorts if you want, and get each instance via the `items` key. */
  _componentInstances?: _componentsGenqlSelection;
  /** The diff between the current branch and the head commit. */
  _diff?:
    | {
        __args: {
          /** Simplified diff returns only the items array showing statuses. */
          simplified?: Scalars["Boolean"] | null;
        };
      }
    | boolean
    | number;
  /** The structure of the repository. Used by START. */
  _structure?:
    | {
        __args: {
          /** The format of the structure. */
          format?: _StructureFormatEnum | null;
          /** The format of the structure. */
          resolveTargetsWith?: _ResolveTargetsWithEnum | null;
          /** A target block to forcefully resolve in the schema. */
          targetBlock?: TargetBlock | null;
          /** Whether to include constraints in the structure. */
          withConstraints?: Scalars["Boolean"] | null;
          /** Whether to include IDs in the structure. */
          withIDs?: Scalars["Boolean"] | null;
          /** Whether to include type options in the structure. */
          withTypeOptions?: Scalars["Boolean"] | null;
        };
      }
    | boolean
    | number;
  _sys?: RepoSysGenqlSelection;
  blog?: BlogGenqlSelection;
  legalPages?: LegalPagesGenqlSelection & {
    __args?: {
      /** Filter by a field. */
      filter?: LegalPagesItemFilterInput | null;
      /** Limit the number of items returned. Defaults to 500. */
      first?: Scalars["Int"] | null;
      /** Order by a field. */
      orderBy?: LegalPagesItemOrderByEnum | null;
      /** Search configuration */
      search?: LegalPagesItemSearchInput | null;
      /** Skip the first n items. */
      skip?: Scalars["Int"] | null;
    };
  };
  __typename?: boolean | number;
  __fragmentOn?: "Query";
};

export type RepoSysGenqlSelection = {
  branches?: _BranchesGenqlSelection & {
    __args?: { limit?: Scalars["Int"] | null; offset?: Scalars["Int"] | null };
  };
  dashboardUrl?: boolean | number;
  forkUrl?: boolean | number;
  hash?: boolean | number;
  id?: boolean | number;
  playgroundInfo?: _PlaygroundInfoGenqlSelection;
  slug?: boolean | number;
  title?: boolean | number;
  __typename?: boolean | number;
  __fragmentOn?: "RepoSys";
};

export type RichTextJsonGenqlSelection = {
  content?: boolean | number;
  toc?: boolean | number;
  on_BaseRichTextJson?: BaseRichTextJsonGenqlSelection;
  on_BodyRichText?: BodyRichTextGenqlSelection;
  on_Body_1RichText?: Body_1RichTextGenqlSelection;
  __typename?: boolean | number;
  __fragmentOn?: "RichTextJson";
};

export type SearchHighlightGenqlSelection = {
  /** The field/path that was matched (e.g., "title", "body.content") */
  by?: boolean | number;
  /** HTML snippet with <mark> tags around the matched terms */
  snippet?: boolean | number;
  __typename?: boolean | number;
  __fragmentOn?: "SearchHighlight";
};

export type SelectFilter = {
  excludes?: Scalars["String"] | null;
  excludesAll?: Scalars["String"][] | null;
  includes?: Scalars["String"] | null;
  includesAll?: Scalars["String"][] | null;
  includesAny?: Scalars["String"][] | null;
  isEmpty?: Scalars["Boolean"] | null;
};

export type StringFilter = {
  contains?: Scalars["String"] | null;
  endsWith?: Scalars["String"] | null;
  eq?: Scalars["String"] | null;
  in?: Scalars["String"][] | null;
  isNull?: Scalars["Boolean"] | null;
  matches?: StringMatchesFilter | null;
  notEq?: Scalars["String"] | null;
  notIn?: Scalars["String"][] | null;
  startsWith?: Scalars["String"] | null;
};

export type StringMatchesFilter = {
  caseSensitive?: Scalars["Boolean"] | null;
  pattern: Scalars["String"];
};

export type TargetBlock = {
  focus?: Scalars["Boolean"] | null;
  id: Scalars["String"];
  label: Scalars["String"];
};

export type TransactionStatusGenqlSelection = {
  /** Duration in milliseconds. */
  duration?: boolean | number;
  endedAt?: boolean | number;
  id?: boolean | number;
  message?: boolean | number;
  startedAt?: boolean | number;
  status?: boolean | number;
  __typename?: boolean | number;
  __fragmentOn?: "TransactionStatus";
};

export type VariantGenqlSelection = {
  apiName?: boolean | number;
  color?: boolean | number;
  id?: boolean | number;
  isDefault?: boolean | number;
  label?: boolean | number;
  __typename?: boolean | number;
  __fragmentOn?: "Variant";
};

export type _AgentStartGenqlSelection = {
  _agentKey?: boolean | number;
  _analyticsKey?:
    | {
        __args: {
          /**
           * The scope of the analytics key. Use `send` for just ingesting data. Use `query` if you need to show an analytics data in your website.
           *
           * Have in mind, if you expose your `query` analytics key in the frontend, you'll be exposing all of this block's analytics data to the public. This is generally safe, but it might not be in your case.
           */
          scope?: AnalyticsKeyScope | null;
        };
      }
    | boolean
    | number;
  _dashboardUrl?: boolean | number;
  _id?: boolean | number;
  _idPath?: boolean | number;
  _slug?: boolean | number;
  _slugPath?: boolean | number;
  _sys?: BlockDocumentSysGenqlSelection;
  _title?: boolean | number;
  accent?: boolean | number;
  avatar?: boolean | number;
  chatUrl?: boolean | number;
  commit?: boolean | number;
  description?: boolean | number;
  edit?: boolean | number;
  embedUrl?: boolean | number;
  getUserInfo?: boolean | number;
  grayscale?: boolean | number;
  manageBranches?: boolean | number;
  mcpUrl?: boolean | number;
  model?: boolean | number;
  openRouterKey?: boolean | number;
  searchTheWeb?: boolean | number;
  slackInstallUrl?: boolean | number;
  systemPrompt?: boolean | number;
  __typename?: boolean | number;
  __fragmentOn?: "_AgentStart";
};

export type _BranchInfoGenqlSelection = {
  archivedAt?: boolean | number;
  archivedBy?: boolean | number;
  authorId?: boolean | number;
  contributors?: boolean | number;
  createdAt?: boolean | number;
  description?: boolean | number;
  git?: _GitInfoGenqlSelection;
  headCommit?: _CommitInfoGenqlSelection;
  headCommitId?: boolean | number;
  id?: boolean | number;
  inlineSuggestionAppliedAt?: boolean | number;
  isDefault?: boolean | number;
  isInlineSuggestion?: boolean | number;
  name?: boolean | number;
  playgroundId?: boolean | number;
  rollbackCommitId?: boolean | number;
  rollbackIsoDate?: boolean | number;
  sourceBranchId?: boolean | number;
  updatedAt?: boolean | number;
  workingRootBlockId?: boolean | number;
  __typename?: boolean | number;
  __fragmentOn?: "_BranchInfo";
};

export type _BranchesGenqlSelection = {
  _meta?: ListMetaGenqlSelection;
  items?: _BranchInfoGenqlSelection;
  __typename?: boolean | number;
  __fragmentOn?: "_Branches";
};

export type _CommitInfoGenqlSelection = {
  authorId?: boolean | number;
  branchId?: boolean | number;
  contributors?: boolean | number;
  createdAt?: boolean | number;
  hash?: boolean | number;
  id?: boolean | number;
  mergeParentCommitId?: boolean | number;
  message?: boolean | number;
  parentCommitId?: boolean | number;
  /** Whether this commit is from a playground branch. */
  playgroundId?: boolean | number;
  repoId?: boolean | number;
  rootBlockId?: boolean | number;
  __typename?: boolean | number;
  __fragmentOn?: "_CommitInfo";
};

export type _GitInfoGenqlSelection = {
  branch?: boolean | number;
  deploymentUrl?: boolean | number;
  __typename?: boolean | number;
  __fragmentOn?: "_GitInfo";
};

export type _PlaygroundInfoGenqlSelection = {
  claimUrl?: boolean | number;
  editUrl?: boolean | number;
  expiresAt?: boolean | number;
  id?: boolean | number;
  __typename?: boolean | number;
  __fragmentOn?: "_PlaygroundInfo";
};

export type _agentsGenqlSelection = {
  start?: _AgentStartGenqlSelection;
  __typename?: boolean | number;
  __fragmentOn?: "_agents";
};

export type _componentsGenqlSelection = {
  authorsItem?: authorsItem_AsListGenqlSelection & {
    __args?: {
      /** Filter by a field. */
      filter?: AuthorsItemFilterInput | null;
      /** Limit the number of items returned. Defaults to 500. */
      first?: Scalars["Int"] | null;
      /** Order by a field. */
      orderBy?: AuthorsItemOrderByEnum | null;
      /** Search configuration */
      search?: AuthorsItemSearchInput | null;
      /** Skip the first n items. */
      skip?: Scalars["Int"] | null;
    };
  };
  categoriesItem?: categoriesItem_AsListGenqlSelection & {
    __args?: {
      /** Filter by a field. */
      filter?: CategoriesItemFilterInput | null;
      /** Limit the number of items returned. Defaults to 500. */
      first?: Scalars["Int"] | null;
      /** Order by a field. */
      orderBy?: CategoriesItemOrderByEnum | null;
      /** Search configuration */
      search?: CategoriesItemSearchInput | null;
      /** Skip the first n items. */
      skip?: Scalars["Int"] | null;
    };
  };
  legalPagesItem?: legalPagesItem_AsListGenqlSelection & {
    __args?: {
      /** Filter by a field. */
      filter?: LegalPagesItemFilterInput | null;
      /** Limit the number of items returned. Defaults to 500. */
      first?: Scalars["Int"] | null;
      /** Order by a field. */
      orderBy?: LegalPagesItemOrderByEnum | null;
      /** Search configuration */
      search?: LegalPagesItemSearchInput | null;
      /** Skip the first n items. */
      skip?: Scalars["Int"] | null;
    };
  };
  postsItem?: postsItem_AsListGenqlSelection & {
    __args?: {
      /** Filter by a field. */
      filter?: PostsItemFilterInput | null;
      /** Limit the number of items returned. Defaults to 500. */
      first?: Scalars["Int"] | null;
      /** Order by a field. */
      orderBy?: PostsItemOrderByEnum | null;
      /** Search configuration */
      search?: PostsItemSearchInput | null;
      /** Skip the first n items. */
      skip?: Scalars["Int"] | null;
    };
  };
  __typename?: boolean | number;
  __fragmentOn?: "_components";
};

export type authorsItem_AsListGenqlSelection = {
  _analyticsKey?:
    | {
        __args: {
          /**
           * The scope of the analytics key. Use `send` for just ingesting data. Use `query` if you need to show an analytics data in your website.
           *
           * Have in mind, if you expose your `query` analytics key in the frontend, you'll be exposing all of this block's analytics data to the public. This is generally safe, but it might not be in your case.
           */
          scope?: AnalyticsKeyScope | null;
        };
      }
    | boolean
    | number;
  _dashboardUrl?: boolean | number;
  _id?: boolean | number;
  _idPath?: boolean | number;
  _meta?: ListMetaGenqlSelection;
  /** The key used to search from the frontend. */
  _searchKey?: boolean | number;
  _slug?: boolean | number;
  _slugPath?: boolean | number;
  _sys?: BlockDocumentSysGenqlSelection;
  _title?: boolean | number;
  /** Returns the first item in the list, or null if the list is empty. Useful when you expect only one result. */
  item?: AuthorsItemGenqlSelection;
  /** Returns the list of items after filtering and paginating according to the arguments sent by the client. */
  items?: AuthorsItemGenqlSelection;
  __typename?: boolean | number;
  __fragmentOn?: "authorsItem_AsList";
};

export type categoriesItem_AsListGenqlSelection = {
  _analyticsKey?:
    | {
        __args: {
          /**
           * The scope of the analytics key. Use `send` for just ingesting data. Use `query` if you need to show an analytics data in your website.
           *
           * Have in mind, if you expose your `query` analytics key in the frontend, you'll be exposing all of this block's analytics data to the public. This is generally safe, but it might not be in your case.
           */
          scope?: AnalyticsKeyScope | null;
        };
      }
    | boolean
    | number;
  _dashboardUrl?: boolean | number;
  _id?: boolean | number;
  _idPath?: boolean | number;
  _meta?: ListMetaGenqlSelection;
  /** The key used to search from the frontend. */
  _searchKey?: boolean | number;
  _slug?: boolean | number;
  _slugPath?: boolean | number;
  _sys?: BlockDocumentSysGenqlSelection;
  _title?: boolean | number;
  /** Returns the first item in the list, or null if the list is empty. Useful when you expect only one result. */
  item?: CategoriesItemGenqlSelection;
  /** Returns the list of items after filtering and paginating according to the arguments sent by the client. */
  items?: CategoriesItemGenqlSelection;
  __typename?: boolean | number;
  __fragmentOn?: "categoriesItem_AsList";
};

export type legalPagesItem_AsListGenqlSelection = {
  _analyticsKey?:
    | {
        __args: {
          /**
           * The scope of the analytics key. Use `send` for just ingesting data. Use `query` if you need to show an analytics data in your website.
           *
           * Have in mind, if you expose your `query` analytics key in the frontend, you'll be exposing all of this block's analytics data to the public. This is generally safe, but it might not be in your case.
           */
          scope?: AnalyticsKeyScope | null;
        };
      }
    | boolean
    | number;
  _dashboardUrl?: boolean | number;
  _id?: boolean | number;
  _idPath?: boolean | number;
  _meta?: ListMetaGenqlSelection;
  /** The key used to search from the frontend. */
  _searchKey?: boolean | number;
  _slug?: boolean | number;
  _slugPath?: boolean | number;
  _sys?: BlockDocumentSysGenqlSelection;
  _title?: boolean | number;
  /** Returns the first item in the list, or null if the list is empty. Useful when you expect only one result. */
  item?: LegalPagesItemGenqlSelection;
  /** Returns the list of items after filtering and paginating according to the arguments sent by the client. */
  items?: LegalPagesItemGenqlSelection;
  __typename?: boolean | number;
  __fragmentOn?: "legalPagesItem_AsList";
};

export type postsItem_AsListGenqlSelection = {
  _analyticsKey?:
    | {
        __args: {
          /**
           * The scope of the analytics key. Use `send` for just ingesting data. Use `query` if you need to show an analytics data in your website.
           *
           * Have in mind, if you expose your `query` analytics key in the frontend, you'll be exposing all of this block's analytics data to the public. This is generally safe, but it might not be in your case.
           */
          scope?: AnalyticsKeyScope | null;
        };
      }
    | boolean
    | number;
  _dashboardUrl?: boolean | number;
  _id?: boolean | number;
  _idPath?: boolean | number;
  _meta?: ListMetaGenqlSelection;
  /** The key used to search from the frontend. */
  _searchKey?: boolean | number;
  _slug?: boolean | number;
  _slugPath?: boolean | number;
  _sys?: BlockDocumentSysGenqlSelection;
  _title?: boolean | number;
  /** Returns the first item in the list, or null if the list is empty. Useful when you expect only one result. */
  item?: PostsItemGenqlSelection;
  /** Returns the list of items after filtering and paginating according to the arguments sent by the client. */
  items?: PostsItemGenqlSelection;
  __typename?: boolean | number;
  __fragmentOn?: "postsItem_AsList";
};

export type FragmentsMap = {
  Authors: {
    root: Authors;
    selection: AuthorsGenqlSelection;
  };
  AuthorsItem: {
    root: AuthorsItem;
    selection: AuthorsItemGenqlSelection;
  };
  BaseRichTextJson: {
    root: BaseRichTextJson;
    selection: BaseRichTextJsonGenqlSelection;
  };
  BlockAudio: {
    root: BlockAudio;
    selection: BlockAudioGenqlSelection;
  };
  BlockCodeSnippet: {
    root: BlockCodeSnippet;
    selection: BlockCodeSnippetGenqlSelection;
  };
  BlockColor: {
    root: BlockColor;
    selection: BlockColorGenqlSelection;
  };
  BlockDocument: {
    root: BlockDocument;
    selection: BlockDocumentGenqlSelection;
  };
  BlockDocumentSys: {
    root: BlockDocumentSys;
    selection: BlockDocumentSysGenqlSelection;
  };
  BlockFile: {
    root: BlockFile;
    selection: BlockFileGenqlSelection;
  };
  BlockImage: {
    root: BlockImage;
    selection: BlockImageGenqlSelection;
  };
  BlockList: {
    root: BlockList;
    selection: BlockListGenqlSelection;
  };
  BlockOgImage: {
    root: BlockOgImage;
    selection: BlockOgImageGenqlSelection;
  };
  BlockRichText: {
    root: BlockRichText;
    selection: BlockRichTextGenqlSelection;
  };
  BlockVideo: {
    root: BlockVideo;
    selection: BlockVideoGenqlSelection;
  };
  Blog: {
    root: Blog;
    selection: BlogGenqlSelection;
  };
  Body: {
    root: Body;
    selection: BodyGenqlSelection;
  };
  BodyRichText: {
    root: BodyRichText;
    selection: BodyRichTextGenqlSelection;
  };
  Body_1: {
    root: Body_1;
    selection: Body_1GenqlSelection;
  };
  Body_1RichText: {
    root: Body_1RichText;
    selection: Body_1RichTextGenqlSelection;
  };
  Categories: {
    root: Categories;
    selection: CategoriesGenqlSelection;
  };
  CategoriesItem: {
    root: CategoriesItem;
    selection: CategoriesItemGenqlSelection;
  };
  GetUploadSignedURL: {
    root: GetUploadSignedURL;
    selection: GetUploadSignedURLGenqlSelection;
  };
  LegalPages: {
    root: LegalPages;
    selection: LegalPagesGenqlSelection;
  };
  LegalPagesItem: {
    root: LegalPagesItem;
    selection: LegalPagesItemGenqlSelection;
  };
  ListMeta: {
    root: ListMeta;
    selection: ListMetaGenqlSelection;
  };
  MediaBlock: {
    root: MediaBlock;
    selection: MediaBlockGenqlSelection;
  };
  Mutation: {
    root: Mutation;
    selection: MutationGenqlSelection;
  };
  Posts: {
    root: Posts;
    selection: PostsGenqlSelection;
  };
  PostsItem: {
    root: PostsItem;
    selection: PostsItemGenqlSelection;
  };
  Query: {
    root: Query;
    selection: QueryGenqlSelection;
  };
  RepoSys: {
    root: RepoSys;
    selection: RepoSysGenqlSelection;
  };
  RichTextJson: {
    root: RichTextJson;
    selection: RichTextJsonGenqlSelection;
  };
  SearchHighlight: {
    root: SearchHighlight;
    selection: SearchHighlightGenqlSelection;
  };
  TransactionStatus: {
    root: TransactionStatus;
    selection: TransactionStatusGenqlSelection;
  };
  Variant: {
    root: Variant;
    selection: VariantGenqlSelection;
  };
  _AgentStart: {
    root: _AgentStart;
    selection: _AgentStartGenqlSelection;
  };
  _BranchInfo: {
    root: _BranchInfo;
    selection: _BranchInfoGenqlSelection;
  };
  _Branches: {
    root: _Branches;
    selection: _BranchesGenqlSelection;
  };
  _CommitInfo: {
    root: _CommitInfo;
    selection: _CommitInfoGenqlSelection;
  };
  _GitInfo: {
    root: _GitInfo;
    selection: _GitInfoGenqlSelection;
  };
  _PlaygroundInfo: {
    root: _PlaygroundInfo;
    selection: _PlaygroundInfoGenqlSelection;
  };
  _agents: {
    root: _agents;
    selection: _agentsGenqlSelection;
  };
  _components: {
    root: _components;
    selection: _componentsGenqlSelection;
  };
  authorsItem_AsList: {
    root: authorsItem_AsList;
    selection: authorsItem_AsListGenqlSelection;
  };
  categoriesItem_AsList: {
    root: categoriesItem_AsList;
    selection: categoriesItem_AsListGenqlSelection;
  };
  legalPagesItem_AsList: {
    root: legalPagesItem_AsList;
    selection: legalPagesItem_AsListGenqlSelection;
  };
  postsItem_AsList: {
    root: postsItem_AsList;
    selection: postsItem_AsListGenqlSelection;
  };
};
