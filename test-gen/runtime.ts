// Generated by Manifest Compiler v2.0
// This code is a PROJECTION from a Manifest source file.
// The IR (Intermediate Representation) is the single source of truth.
// This generated code should not be edited manually.
//
// Provenance:
//   Compiler Version: 0.3.0
//   Schema Version: 1.0
//   Generated At: 2026-02-07T01:59:44.735Z
//
// Includes: Commands, Computed Properties, Relationships, Policies, Stores, Events

type Subscriber<T> = (value: T) => void;
type User = { id: string; role?: string; [key: string]: unknown };
type Context = { user?: User; [key: string]: unknown };

let _context: Context = {};
const setContext = (ctx: Context) => {
  _context = ctx;
};
const getContext = () => _context;

class Observable<T> {
  private subs: Set<Subscriber<T>> = new Set();
  private _v: T;
  constructor(v: T) {
    this._v = v;
  }
  get value(): T {
    return this._v;
  }
  set(v: T) {
    this._v = v;
    this.subs.forEach((fn) => fn(v));
  }
  subscribe(fn: Subscriber<T>) {
    this.subs.add(fn);
    fn(this._v);
    return () => this.subs.delete(fn);
  }
}

class EventEmitter<T extends Record<string, unknown>> {
  private listeners: Map<keyof T, Set<(d: unknown) => void>> = new Map();
  on<K extends keyof T>(e: K, fn: (d: T[K]) => void) {
    if (!this.listeners.has(e)) this.listeners.set(e, new Set());
    this.listeners.get(e)!.add(fn);
    return () => this.listeners.get(e)?.delete(fn);
  }
  emit<K extends keyof T>(e: K, d: T[K]) {
    this.listeners.get(e)?.forEach((fn) => fn(d));
  }
}

class EventBus {
  private static channels: Map<string, Set<(d: unknown) => void>> = new Map();
  static publish(channel: string, data: unknown) {
    EventBus.channels.get(channel)?.forEach((fn) => fn(data));
  }
  static subscribe(channel: string, fn: (d: unknown) => void) {
    if (!EventBus.channels.has(channel))
      EventBus.channels.set(channel, new Set());
    EventBus.channels.get(channel)!.add(fn);
    return () => EventBus.channels.get(channel)?.delete(fn);
  }
}

interface Store<T> {
  getAll(): Promise<T[]>;
  getById(id: string): Promise<T | null>;
  create(item: Partial<T>): Promise<T>;
  update(id: string, item: Partial<T>): Promise<T>;
  delete(id: string): Promise<boolean>;
  query(filter: (item: T) => boolean): Promise<T[]>;
}

class MemoryStore<T extends { id: string }> implements Store<T> {
  private data: Map<string, T> = new Map();
  async getAll() {
    return Array.from(this.data.values());
  }
  async getById(id: string) {
    return this.data.get(id) || null;
  }
  async create(item: Partial<T>) {
    const id = item.id || crypto.randomUUID();
    const full = { ...item, id } as T;
    this.data.set(id, full);
    return full;
  }
  async update(id: string, item: Partial<T>) {
    const existing = this.data.get(id);
    if (!existing) throw new Error("Not found");
    const updated = { ...existing, ...item };
    this.data.set(id, updated);
    return updated;
  }
  async delete(id: string) {
    return this.data.delete(id);
  }
  async query(filter: (item: T) => boolean) {
    return Array.from(this.data.values()).filter(filter);
  }
}

class LocalStorageStore<T extends { id: string }> implements Store<T> {
  constructor(private key: string) {}
  private load(): T[] {
    const d = localStorage.getItem(this.key);
    return d ? JSON.parse(d) : [];
  }
  private save(data: T[]) {
    localStorage.setItem(this.key, JSON.stringify(data));
  }
  async getAll() {
    return this.load();
  }
  async getById(id: string) {
    return this.load().find((x) => x.id === id) || null;
  }
  async create(item: Partial<T>) {
    const data = this.load();
    const id = item.id || crypto.randomUUID();
    const full = { ...item, id } as T;
    data.push(full);
    this.save(data);
    return full;
  }
  async update(id: string, item: Partial<T>) {
    const data = this.load();
    const idx = data.findIndex((x) => x.id === id);
    if (idx < 0) throw new Error("Not found");
    data[idx] = { ...data[idx], ...item };
    this.save(data);
    return data[idx];
  }
  async delete(id: string) {
    const data = this.load();
    const idx = data.findIndex((x) => x.id === id);
    if (idx < 0) return false;
    data.splice(idx, 1);
    this.save(data);
    return true;
  }
  async query(filter: (item: T) => boolean) {
    return this.load().filter(filter);
  }
}

interface ITestEntity {
  id: string;
  name: string;
  count?: number;
}

class TestEntity extends EventEmitter<{ TestEntityUpdated: unknown }> {
  private _id = new Observable("");
  private _name = new Observable("");
  private _count = new Observable(0);

  get id() {
    return this._id.value;
  }
  set id(v: string) {
    if (!(this.count >= 0)) throw new Error("Count must be non-negative");
    const old = this._id.value;
    this._id.set(v);
    if (old !== v) this._recompute();
  }
  get name() {
    return this._name.value;
  }
  set name(v: string) {
    if (!(this.count >= 0)) throw new Error("Count must be non-negative");
    const old = this._name.value;
    this._name.set(v);
    if (old !== v) this._recompute();
  }
  get count() {
    return this._count.value;
  }
  set count(v: number) {
    if (!(v >= 0)) throw new Error("Count must be non-negative");
    const old = this._count.value;
    this._count.set(v);
    if (old !== v) this._recompute();
  }

  constructor(init?: Partial<ITestEntity>) {
    super();
    if (init) {
      if (init.id !== undefined) this._id.set(init.id);
      if (init.name !== undefined) this._name.set(init.name);
      if (init.count !== undefined) this._count.set(init.count);
    }
    this._initBehaviors();
    this._recompute();
  }

  private _recompute() {}

  private _initBehaviors() {}

  subscribe(prop: keyof ITestEntity, fn: (v: unknown) => void) {
    return (this as Record<string, unknown>)[`_${prop}`]?.subscribe?.(fn);
  }

  toJSON() {
    return {
      id: this.id,
      name: this.name,
      count: this.count,
    };
  }

  async updateName(newName: string): Promise<unknown> {
    // Guard checks
    if (!(newName != null && newName != ""))
      throw new Error("Guard failed for updateName");
    let _result: unknown;
    _result = "Name is required";
    _result = this.name = newName;
    _result = this.emit("TestEntityUpdated", {});
    this.emit("TestEntityUpdated", { newName });
    return _result as unknown;
  }
}

interface TestEntityUpdatedEvent {
  entityId: string;
  name: string;
}

const publishTestEntityUpdated = (data: TestEntityUpdatedEvent) => {
  EventBus.publish("test.updated", data);
};

export {
  setContext,
  getContext,
  EventBus,
  TestEntity,
  publishTestEntityUpdated,
  type subscribeTestEntityUpdated,
};
