-- MIGRATION: 20251222000112_tenant_admin.sql
-- Admin module: admin_users, admin_roles, admin_permissions, admin_audit_trail
-- All tables follow Schema Contract v2 with composite PK (tenant_id, id)

-- Create schema if not exists
CREATE SCHEMA IF NOT EXISTS tenant_admin AUTHORIZATION postgres;

-- ============================================
-- ENUM TYPES
-- ============================================

CREATE TYPE tenant_admin.admin_action AS ENUM (
  'login', 'logout', 'create', 'update', 'delete', 'view',
  'permission_change', 'role_change', 'account_change', 'security_change'
);

CREATE TYPE tenant_admin.admin_entity_type AS ENUM (
  'admin_users', 'admin_roles', 'admin_permissions', 'admin_audit_trail',
  'users', 'roles', 'permissions', 'tenants', 'reports', 'settings'
);

CREATE TYPE tenant_admin.admin_role AS ENUM (
  'super_admin', 'tenant_admin', 'finance_manager',
  'operations_manager', 'staff_manager', 'read_only'
);

-- ============================================
-- TENANT_ADMIN.ADMIN_ROLES
-- ============================================

CREATE TABLE tenant_admin.admin_roles (
  tenant_id uuid NOT NULL REFERENCES platform.accounts(id) ON DELETE RESTRICT,
  id uuid DEFAULT gen_random_uuid(),
  role_name tenant_admin.admin_role NOT NULL,
  description text,
  permissions jsonb DEFAULT '[]'::jsonb,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  deleted_at timestamptz NULL,
  PRIMARY KEY (tenant_id, id),
  CHECK (length(trim(description)) <= 1000),
  CHECK (jsonb_typeof(permissions) = 'array')
);

-- Indexes
CREATE INDEX admin_roles_tenant_name_idx
  ON tenant_admin.admin_roles(tenant_id, role_name) WHERE deleted_at IS NULL;

-- Partial unique index after table creation
CREATE UNIQUE INDEX admin_roles_tenant_name_active_idx
  ON tenant_admin.admin_roles(tenant_id, role_name)
  WHERE deleted_at IS NULL;

-- Triggers
CREATE TRIGGER admin_roles_update_timestamp
  BEFORE UPDATE ON tenant_admin.admin_roles
  FOR EACH ROW EXECUTE FUNCTION core.fn_update_timestamp();

CREATE TRIGGER admin_roles_prevent_tenant_mutation
  BEFORE UPDATE ON tenant_admin.admin_roles
  FOR EACH ROW EXECUTE FUNCTION core.fn_prevent_tenant_mutation();

CREATE TRIGGER admin_roles_audit_trigger
  AFTER INSERT OR UPDATE OR DELETE ON tenant_admin.admin_roles
  FOR EACH ROW EXECUTE FUNCTION core.fn_audit_trigger();

-- RLS Policies
ALTER TABLE tenant_admin.admin_roles ENABLE ROW LEVEL SECURITY;
ALTER TABLE tenant_admin.admin_roles FORCE ROW LEVEL SECURITY;

-- Role Management Policies
CREATE POLICY admin_roles_select ON tenant_admin.admin_roles
  FOR SELECT USING (
    tenant_id = (auth.jwt() ->> 'tenant_id')::uuid
    AND deleted_at IS NULL
    AND (
      tenant_admin.fn_has_permission('roles.view'::text) OR
      -- Allow access to one's own role
      EXISTS (
        SELECT 1 FROM tenant_admin.admin_users u
        WHERE u.tenant_id = (auth.jwt() ->> 'tenant_id')::uuid
        AND u.auth_user_id = auth.uid()
        AND u.role = admin_roles.id
      )
    )
  );

CREATE POLICY admin_roles_insert ON tenant_admin.admin_roles
  FOR INSERT WITH CHECK (
    tenant_id = (auth.jwt() ->> 'tenant_id')::uuid
    AND tenant_admin.fn_has_permission('roles.create'::text)
  );

CREATE POLICY admin_roles_update ON tenant_admin.admin_roles
  FOR UPDATE USING (
    tenant_id = (auth.jwt() ->> 'tenant_id')::uuid
    AND deleted_at IS NULL
    AND (
      tenant_admin.fn_has_permission('roles.update'::text) OR
      -- Allow users to update their own role permissions (not others)
      EXISTS (
        SELECT 1 FROM tenant_admin.admin_users u
        WHERE u.tenant_id = (auth.jwt() ->> 'tenant_id')::uuid
        AND u.auth_user_id = auth.uid()
        AND u.role = admin_roles.id
      )
    )
  );

CREATE POLICY admin_roles_delete ON tenant_admin.admin_roles
  FOR DELETE USING (
    tenant_id = (auth.jwt() ->> 'tenant_id')::uuid
    AND deleted_at IS NULL
    AND tenant_admin.fn_has_permission('roles.delete'::text)
  );

-- ============================================
-- TENANT_ADMIN.ADMIN_PERMISSIONS
-- ============================================

CREATE TABLE tenant_admin.admin_permissions (
  tenant_id uuid NOT NULL REFERENCES platform.accounts(id) ON DELETE RESTRICT,
  id uuid DEFAULT gen_random_uuid(),
  permission_name text NOT NULL,
  resource text NOT NULL,
  action text NOT NULL,
  description text NOT NULL,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  deleted_at timestamptz NULL,
  PRIMARY KEY (tenant_id, id),
  UNIQUE (tenant_id, permission_name, resource, action) WHERE deleted_at IS NULL
);

-- Indexes
CREATE INDEX admin_permissions_tenant_id_permission_name_idx
  ON tenant_admin.admin_permissions(tenant_id, permission_name) WHERE deleted_at IS NULL;

CREATE INDEX admin_permissions_tenant_id_resource_action_idx
  ON tenant_admin.admin_permissions(tenant_id, resource, action) WHERE deleted_at IS NULL;

CREATE INDEX admin_permissions_tenant_resource_action_idx
  ON tenant_admin.admin_permissions(tenant_id, resource, action);

CREATE INDEX admin_permissions_tenant_name_active_idx
  ON tenant_admin.admin_permissions(tenant_id, permission_name)
  WHERE deleted_at IS NULL;

CREATE INDEX admin_permissions_tenant_resource_action_active_idx
  ON tenant_admin.admin_permissions(tenant_id, resource, action)
  WHERE deleted_at IS NULL;

-- Triggers
CREATE TRIGGER admin_permissions_update_timestamp
  BEFORE UPDATE ON tenant_admin.admin_permissions
  FOR EACH ROW EXECUTE FUNCTION core.fn_update_timestamp();

CREATE TRIGGER admin_permissions_prevent_tenant_mutation
  BEFORE UPDATE ON tenant_admin.admin_permissions
  FOR EACH ROW EXECUTE FUNCTION core.fn_prevent_tenant_mutation();

CREATE TRIGGER admin_permissions_audit_trigger
  AFTER INSERT OR UPDATE OR DELETE ON tenant_admin.admin_permissions
  FOR EACH ROW EXECUTE FUNCTION core.fn_audit_trigger();

-- RLS Policies
ALTER TABLE tenant_admin.admin_permissions ENABLE ROW LEVEL SECURITY;
ALTER TABLE tenant_admin.admin_permissions FORCE ROW LEVEL SECURITY;

CREATE POLICY admin_permissions_select ON tenant_admin.admin_permissions
  FOR SELECT USING (
    tenant_id = (auth.jwt() ->> 'tenant_id')::uuid
    AND deleted_at IS NULL
    AND tenant_admin.fn_has_permission('permissions.view'::text)
  );

CREATE POLICY admin_permissions_insert ON tenant_admin.admin_permissions
  FOR INSERT WITH CHECK (
    tenant_id = (auth.jwt() ->> 'tenant_id')::uuid
    AND tenant_admin.fn_has_permission('permissions.create'::text)
  );

CREATE POLICY admin_permissions_update ON tenant_admin.admin_permissions
  FOR UPDATE USING (
    tenant_id = (auth.jwt() ->> 'tenant_id')::uuid
    AND deleted_at IS NULL
    AND tenant_admin.fn_has_permission('permissions.update'::text)
  );

CREATE POLICY admin_permissions_delete ON tenant_admin.admin_permissions
  FOR DELETE USING (
    tenant_id = (auth.jwt() ->> 'tenant_id')::uuid
    AND deleted_at IS NULL
    AND tenant_admin.fn_has_permission('permissions.delete'::text)
  );

-- ============================================
-- TENANT_ADMIN.ADMIN_USERS
-- ============================================

CREATE TABLE tenant_admin.admin_users (
  tenant_id uuid NOT NULL REFERENCES platform.accounts(id) ON DELETE RESTRICT,
  id uuid DEFAULT gen_random_uuid(),
  auth_user_id uuid NOT NULL,
  role uuid NOT NULL REFERENCES tenant_admin.admin_roles(tenant_id, id) ON DELETE RESTRICT,
  is_active boolean NOT NULL DEFAULT true,
  last_login timestamptz,
  last_failed_login timestamptz,
  failed_login_attempts smallint DEFAULT 0,
  locked_until timestamptz,
  two_factor_enabled boolean NOT NULL DEFAULT false,
  two_factor_secret text,
  login_ip text,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  deleted_at timestamptz NULL,
  PRIMARY KEY (tenant_id, id),
  UNIQUE (tenant_id, auth_user_id) WHERE deleted_at IS NULL
);

-- Indexes
CREATE INDEX admin_users_tenant_auth_user_idx
  ON tenant_admin.admin_users(tenant_id, auth_user_id) WHERE deleted_at IS NULL;

CREATE INDEX admin_users_tenant_role_idx
  ON tenant_admin.admin_users(tenant_id, role) WHERE deleted_at IS NULL;

CREATE INDEX admin_users_tenant_active_idx
  ON tenant_admin.admin_users(tenant_id, is_active) WHERE deleted_at IS NULL;

CREATE INDEX admin_users_tenant_last_login_idx
  ON tenant_admin.admin_users(tenant_id, last_login DESC)
  WHERE deleted_at IS NULL AND last_login IS NOT NULL;

-- Triggers
CREATE TRIGGER admin_users_update_timestamp
  BEFORE UPDATE ON tenant_admin.admin_users
  FOR EACH ROW EXECUTE FUNCTION core.fn_update_timestamp();

CREATE TRIGGER admin_users_prevent_tenant_mutation
  BEFORE UPDATE ON tenant_admin.admin_users
  FOR EACH ROW EXECUTE FUNCTION core.fn_prevent_tenant_mutation();

CREATE TRIGGER admin_users_audit_trigger
  AFTER INSERT OR UPDATE OR DELETE ON tenant_admin.admin_users
  FOR EACH ROW EXECUTE FUNCTION core.fn_audit_trigger();

-- RLS Policies
ALTER TABLE tenant_admin.admin_users ENABLE ROW LEVEL SECURITY;
ALTER TABLE tenant_admin.admin_users FORCE ROW LEVEL SECURITY;

CREATE POLICY admin_users_select ON tenant_admin.admin_users
  FOR SELECT USING (
    tenant_id = (auth.jwt() ->> 'tenant_id')::uuid
    AND deleted_at IS NULL
    AND (
      tenant_admin.fn_has_permission('users.view'::text) OR
      auth.uid() = auth_user_id
    )
  );

CREATE POLICY admin_users_insert ON tenant_admin.admin_users
  FOR INSERT WITH CHECK (
    tenant_id = (auth.jwt() ->> 'tenant_id')::uuid
    AND tenant_admin.fn_has_permission('users.create'::text)
  );

CREATE POLICY admin_users_update ON tenant_admin.admin_users
  FOR UPDATE USING (
    tenant_id = (auth.jwt() ->> 'tenant_id')::uuid
    AND deleted_at IS NULL
    AND (
      tenant_admin.fn_has_permission('users.update'::text) OR
      auth.uid() = auth_user_id
    )
  );

CREATE POLICY admin_users_delete ON tenant_admin.admin_users
  FOR DELETE USING (false); -- Never allow deletion

-- Service role bypass for auth integration
CREATE POLICY admin_users_service ON tenant_admin.admin_users
  TO service_role
  USING (true)
  WITH CHECK (true);

-- Check constraints
ALTER TABLE tenant_admin.admin_users
ADD CONSTRAINT admin_users_auth_user_id_check
CHECK (auth_user_id IS NOT NULL);

ALTER TABLE tenant_admin.admin_users
ADD CONSTRAINT admin_users_is_active_check
CHECK (is_active IN (true, false));

ALTER TABLE tenant_admin.admin_users
ADD CONSTRAINT admin_users_last_login_check
CHECK (last_login IS NULL OR last_login < now());

ALTER TABLE tenant_admin.admin_users
ADD CONSTRAINT admin_users_last_failed_login_check
CHECK (last_failed_login IS NULL OR last_failed_login < now());

ALTER TABLE tenant_admin.admin_users
ADD CONSTRAINT admin_users_failed_login_attempts_check
CHECK (failed_login_attempts >= 0 AND failed_login_attempts <= 10);

ALTER TABLE tenant_admin.admin_users
ADD CONSTRAINT admin_users_locked_until_check
CHECK (locked_until IS NULL OR locked_until > now());

ALTER TABLE tenant_admin.admin_users
ADD CONSTRAINT admin_users_two_factor_enabled_check
CHECK (two_factor_enabled IN (true, false));

ALTER TABLE tenant_admin.admin_users
ADD CONSTRAINT admin_users_two_factor_secret_check
CHECK (two_factor_secret IS NULL OR length(trim(two_factor_secret)) <= 100);

ALTER TABLE tenant_admin.admin_users
ADD CONSTRAINT admin_users_login_ip_check
CHECK (login_ip IS NULL OR login_ip ~* '^([0-9]{1,3}\.){3}[0-9]{1,3}$' OR login_ip ~* '^([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$');

-- ============================================
-- TENANT_ADMIN.ADMIN_AUDIT_TRAIL
-- ============================================

CREATE TABLE tenant_admin.admin_audit_trail (
  tenant_id uuid NOT NULL REFERENCES platform.accounts(id) ON DELETE RESTRICT,
  id uuid DEFAULT gen_random_uuid(),
  admin_user_id uuid NOT NULL REFERENCES tenant_admin.admin_users(tenant_id, id) ON DELETE CASCADE,
  entity_type tenant_admin.admin_entity_type NOT NULL,
  entity_id uuid,
  action tenant_admin.admin_action NOT NULL,
  description text,
  changes jsonb,
  old_values jsonb,
  new_values jsonb,
  ip_address inet,
  user_agent text,
  created_at timestamptz NOT NULL DEFAULT now(),
  deleted_at timestamptz NULL,
  PRIMARY KEY (tenant_id, id)
);

-- Indexes
CREATE INDEX admin_audit_trail_admin_user_idx
  ON tenant_admin.admin_audit_trail(tenant_id, admin_user_id) WHERE deleted_at IS NULL;

CREATE INDEX admin_audit_trail_entity_type_idx
  ON tenant_admin.admin_audit_trail(tenant_id, entity_type) WHERE deleted_at IS NULL;

CREATE INDEX admin_audit_trail_action_idx
  ON tenant_admin.admin_audit_trail(tenant_id, action) WHERE deleted_at IS NULL;

CREATE INDEX admin_audit_trail_created_idx
  ON tenant_admin.admin_audit_trail(tenant_id, created_at DESC)
  WHERE deleted_at IS NULL;

CREATE INDEX admin_audit_trail_entity_idx
  ON tenant_admin.admin_audit_trail(tenant_id, entity_type, entity_id)
  WHERE deleted_at IS NULL AND entity_id IS NOT NULL;

-- Triggers
CREATE TRIGGER admin_audit_trail_update_timestamp
  BEFORE UPDATE ON tenant_admin.admin_audit_trail
  FOR EACH ROW EXECUTE FUNCTION core.fn_update_timestamp();

CREATE TRIGGER admin_audit_trail_prevent_tenant_mutation
  BEFORE UPDATE ON tenant_admin.admin_audit_trail
  FOR EACH ROW EXECUTE FUNCTION core.fn_prevent_tenant_mutation();

CREATE TRIGGER admin_audit_trail_audit_trigger
  AFTER INSERT OR UPDATE OR DELETE ON tenant_admin.admin_audit_trail
  FOR EACH ROW EXECUTE FUNCTION core.fn_audit_trigger();

-- RLS Policies
ALTER TABLE tenant_admin.admin_audit_trail ENABLE ROW LEVEL SECURITY;
ALTER TABLE tenant_admin.admin_audit_trail FORCE ROW LEVEL SECURITY;

CREATE POLICY admin_audit_trail_select ON tenant_admin.admin_audit_trail
  FOR SELECT USING (
    tenant_id = (auth.jwt() ->> 'tenant_id')::uuid
    AND deleted_at IS NULL
    AND (
      tenant_admin.fn_has_permission('reports.view'::text) OR
      -- Allow access if user is viewing their own audit records
      EXISTS (
        SELECT 1 FROM tenant_admin.admin_users u
        WHERE u.tenant_id = (auth.jwt() ->> 'tenant_id')::uuid
        AND u.auth_user_id = auth.uid()
        AND u.id = admin_audit_trail.admin_user_id
      )
    )
  );

CREATE POLICY admin_audit_trail_insert ON tenant_admin.admin_audit_trail
  FOR INSERT WITH CHECK (
    tenant_id = (auth.jwt() ->> 'tenant_id')::uuid
    AND tenant_admin.fn_has_permission('reports.create'::text)
  );

CREATE POLICY admin_audit_trail_update ON tenant_admin.admin_audit_trail
  FOR UPDATE USING (
    tenant_id = (auth.jwt() ->> 'tenant_id')::uuid
    AND deleted_at IS NULL
    AND tenant_admin.fn_has_permission('reports.update'::text)
  );

CREATE POLICY admin_audit_trail_delete ON tenant_admin.admin_audit_trail
  FOR DELETE USING (
    tenant_id = (auth.jwt() ->> 'tenant_id')::uuid
    AND deleted_at IS NULL
    AND tenant_admin.fn_has_permission('reports.delete'::text)
  );

-- ============================================
-- UTILITY FUNCTIONS
-- ============================================

-- Check if user has a specific permission
CREATE OR REPLACE FUNCTION tenant_admin.fn_has_permission(p_permission_name text)
RETURNS boolean AS $$
BEGIN
  -- Check if permission exists for the tenant
  RETURN EXISTS (
    SELECT 1 FROM tenant_admin.admin_permissions p
    WHERE p.tenant_id = (auth.jwt() ->> 'tenant_id')::uuid
      AND p.permission_name = p_permission_name
      AND p.deleted_at IS NULL
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Reset failed login attempts
CREATE OR REPLACE FUNCTION tenant_admin.fn_reset_failed_login_attempts()
RETURNS trigger AS $$
BEGIN
  IF NEW.failed_login_attempts > 0 THEN
    NEW.failed_login_attempts := 0;
    NEW.locked_until := NULL;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Log admin action
CREATE OR REPLACE FUNCTION tenant_admin.fn_log_admin_action(
  p_action tenant_admin.admin_action,
  p_entity_type tenant_admin.admin_entity_type,
  p_entity_id uuid DEFAULT NULL,
  p_changes jsonb DEFAULT NULL,
  p_old_values jsonb DEFAULT NULL,
  p_new_values jsonb DEFAULT NULL
)
RETURNS void AS $$
BEGIN
  INSERT INTO tenant_admin.admin_audit_trail (
    tenant_id,
    admin_user_id,
    entity_type,
    entity_id,
    action,
    description,
    changes,
    old_values,
    new_values,
    ip_address,
    user_agent
  ) VALUES (
    (auth.jwt() ->> 'tenant_id')::uuid,
    (SELECT id FROM tenant_admin.admin_users
     WHERE tenant_id = (auth.jwt() ->> 'tenant_id')::uuid
     AND auth_user_id = auth.uid()
     LIMIT 1),
    p_entity_type,
    p_entity_id,
    p_action,
    p_changes->>'description',
    p_changes,
    p_old_values,
    p_new_values,
    inet_client_addr(),
    http_user_agent()
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Validate password strength
CREATE OR REPLACE FUNCTION tenant_admin.fn_validate_password_strength(p_password text)
RETURNS TABLE(is_valid boolean, error_message text) AS $$
BEGIN
  RETURN QUERY
  SELECT
    CASE
      WHEN p_password IS NULL THEN false
      WHEN length(p_password) < 8 THEN false
      WHEN p_password ~ '[A-Z]' IS NULL THEN false
      WHEN p_password ~ '[a-z]' IS NULL THEN false
      WHEN p_password ~ '[0-9]' IS NULL THEN false
      ELSE true
    END,
    CASE
      WHEN p_password IS NULL THEN 'Password is required'
      WHEN length(p_password) < 8 THEN 'Password must be at least 8 characters'
      WHEN p_password ~ '[A-Z]' IS NULL THEN 'Password must contain uppercase letter'
      WHEN p_password ~ '[a-z]' IS NULL THEN 'Password must contain lowercase letter'
      WHEN p_password ~ '[0-9]' IS NULL THEN 'Password must contain number'
      ELSE NULL
    END;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Generate security report
CREATE OR REPLACE FUNCTION tenant_admin.fn_generate_security_report()
RETURNS TABLE(
  total_users integer,
  active_users integer,
  locked_users integer,
  users_with_2fa integer,
  last_login_stats json
) AS $$
BEGIN
  RETURN QUERY
  WITH login_stats AS (
    SELECT
      COUNT(*) as total,
      COUNT(CASE WHEN last_login > now() - INTERVAL '30 days' THEN 1 END) as active_30d,
      COUNT(CASE WHEN last_login > now() - INTERVAL '7 days' THEN 1 END) as active_7d,
      COUNT(CASE WHEN last_login > now() - INTERVAL '24 hours' THEN 1 END) as active_24h
    FROM tenant_admin.admin_users
    WHERE tenant_id = (auth.jwt() ->> 'tenant_id')::uuid
      AND deleted_at IS NULL
  )
  SELECT
    (SELECT COUNT(*) FROM tenant_admin.admin_users WHERE tenant_id = (auth.jwt() ->> 'tenant_id')::uuid AND deleted_at IS NULL),
    (SELECT COUNT(*) FROM tenant_admin.admin_users WHERE tenant_id = (auth.jwt() ->> 'tenant_id')::uuid AND deleted_at IS NULL AND is_active = true),
    (SELECT COUNT(*) FROM tenant_admin.admin_users WHERE tenant_id = (auth.jwt() ->> 'tenant_id')::uuid AND deleted_at IS NULL AND locked_until IS NOT NULL AND locked_until > now()),
    (SELECT COUNT(*) FROM tenant_admin.admin_users WHERE tenant_id = (auth.jwt() ->> 'tenant_id')::uuid AND deleted_at IS NULL AND two_factor_enabled = true),
    to_json(login_stats.*)
  FROM login_stats;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Set default admin user (trigger function)
CREATE OR REPLACE FUNCTION tenant_admin.fn_set_default_admin_user()
RETURNS trigger AS $$
BEGIN
  -- Create default role if not exists
  INSERT INTO tenant_admin.admin_roles (
    tenant_id,
    role_name,
    description,
    permissions
  )
  SELECT
    (auth.jwt() ->> 'tenant_id')::uuid,
    'tenant_admin',
    'Default tenant administrator with full access',
    '["users.view", "users.create", "users.update", "users.delete", "roles.view", "roles.create", "roles.update", "roles.delete", "permissions.view", "permissions.create", "permissions.update", "permissions.delete", "tenants.view", "tenants.create", "tenants.update", "tenants.delete", "reports.view", "reports.create", "reports.update", "reports.delete", "settings.view", "settings.create", "settings.update", "settings.delete"]'::jsonb
  WHERE NOT EXISTS (
    SELECT 1 FROM tenant_admin.admin_roles
    WHERE tenant_id = (auth.jwt() ->> 'tenant_id')::uuid
    AND role_name = 'tenant_admin'
    AND deleted_at IS NULL
  )
  RETURNING id INTO NEW.role;

  -- Create default admin user if auth user doesn't exist
  INSERT INTO tenant_admin.admin_users (
    tenant_id,
    auth_user_id,
    role,
    is_active,
    two_factor_enabled
  )
  SELECT
    (auth.jwt() ->> 'tenant_id')::uuid,
    auth.uid(),
    NEW.role,
    true,
    false
  WHERE NOT EXISTS (
    SELECT 1 FROM tenant_admin.admin_users
    WHERE tenant_id = (auth.jwt() ->> 'tenant_id')::uuid
    AND auth_user_id = auth.uid()
    AND deleted_at IS NULL
  );

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================
-- INSERT DEFAULT DATA (conditional on valid tenant context)
-- ============================================

-- Only insert if we have a valid tenant_id context
DO $$
DECLARE
  v_tenant_id uuid;
BEGIN
  v_tenant_id := (auth.jwt() ->> 'tenant_id')::uuid;

  IF v_tenant_id IS NOT NULL THEN
    -- Insert default roles
    INSERT INTO tenant_admin.admin_roles (
      tenant_id,
      role_name,
      description,
      permissions
    )
    VALUES
      (v_tenant_id, 'super_admin', 'Super administrator with all permissions', '["*.*"]'::jsonb),
      (v_tenant_id, 'tenant_admin', 'Tenant administrator with full access', '["users.*", "roles.*", "permissions.*", "tenants.*", "reports.*", "settings.*"]'::jsonb),
      (v_tenant_id, 'finance_manager', 'Finance manager for financial operations', '["users.view", "users.create", "users.update", "tenants.view", "reports.view", "reports.create"]'::jsonb),
      (v_tenant_id, 'operations_manager', 'Operations manager for daily operations', '["users.view", "users.create", "users.update", "tenants.view", "reports.view"]'::jsonb),
      (v_tenant_id, 'staff_manager', 'Staff manager for personnel management', '["users.view", "users.create", "users.update", "tenants.view"]'::jsonb),
      (v_tenant_id, 'read_only', 'Read-only user with view access', '["users.view", "roles.view", "permissions.view", "tenants.view", "reports.view", "settings.view"]'::jsonb)
    ON CONFLICT (tenant_id, role_name) DO NOTHING;

    -- Insert default permissions
    INSERT INTO tenant_admin.admin_permissions (tenant_id, permission_name, resource, action, description)
    SELECT
      v_tenant_id,
      permission_name,
      resource,
      action,
      description
    FROM (VALUES
      ('users.view', 'users', 'view', 'View user accounts and profiles'),
      ('users.create', 'users', 'create', 'Create new user accounts'),
      ('users.update', 'users', 'update', 'Update existing user accounts'),
      ('users.delete', 'users', 'delete', 'Delete user accounts'),
      ('roles.view', 'roles', 'view', 'View admin roles'),
      ('roles.create', 'roles', 'create', 'Create new admin roles'),
      ('roles.update', 'roles', 'update', 'Update existing admin roles'),
      ('roles.delete', 'roles', 'delete', 'Delete admin roles'),
      ('permissions.view', 'permissions', 'view', 'View permissions'),
      ('permissions.create', 'permissions', 'create', 'Create new permissions'),
      ('permissions.update', 'permissions', 'update', 'Update existing permissions'),
      ('permissions.delete', 'permissions', 'delete', 'Delete permissions'),
      ('tenants.view', 'tenants', 'view', 'View tenant information'),
      ('tenants.create', 'tenants', 'create', 'Create new tenants'),
      ('tenants.update', 'tenants', 'update', 'Update tenant information'),
      ('tenants.delete', 'tenants', 'delete', 'Delete tenants'),
      ('reports.view', 'reports', 'view', 'View system reports'),
      ('reports.create', 'reports', 'create', 'Create new reports'),
      ('reports.update', 'reports', 'update', 'Update existing reports'),
      ('reports.delete', 'reports', 'delete', 'Delete reports'),
      ('settings.view', 'settings', 'view', 'View system settings'),
      ('settings.create', 'settings', 'create', 'Create system settings'),
      ('settings.update', 'settings', 'update', 'Update existing settings'),
      ('settings.delete', 'settings', 'delete', 'Delete system settings')
    ) AS t(permission_name, resource, action, description)
    WHERE NOT EXISTS (
      SELECT 1 FROM tenant_admin.admin_permissions
      WHERE tenant_id = v_tenant_id
        AND permission_name = t.permission_name
        AND deleted_at IS NULL
    );
  END IF;
END $$;

-- ============================================
-- TRIGGER FUNCTION APPLICATIONS
-- ============================================

-- Apply the trigger function for default admin user creation
CREATE TRIGGER admin_users_set_default_admin
  BEFORE INSERT OR UPDATE ON tenant_admin.admin_users
  FOR EACH ROW EXECUTE FUNCTION tenant_admin.fn_set_default_admin_user();

-- Apply the trigger function for resetting failed login attempts
CREATE TRIGGER admin_users_reset_failed_login
  BEFORE UPDATE ON tenant_admin.admin_users
  FOR EACH ROW WHEN (
    OLD.failed_login_attempts > 0
    AND NEW.failed_login_attempts = 0
    AND OLD.locked_until IS NOT NULL
  )
  EXECUTE FUNCTION tenant_admin.fn_reset_failed_login_attempts();

-- ============================================
-- VERIFICATION
-- ============================================

-- Verify tables created
SELECT schemaname, tablename
FROM pg_tables
WHERE schemaname = 'tenant_admin'
ORDER BY tablename;

-- Verify indexes created
SELECT schemaname, tablename, indexname
FROM pg_indexes
WHERE schemaname = 'tenant_admin'
ORDER BY tablename, indexname;

-- Verify RLS enabled
SELECT schemaname, tablename, rowsecurity
FROM pg_tables
WHERE schemaname = 'tenant_admin'
ORDER BY tablename;

-- Verify functions created
SELECT routine_name, routine_type
FROM information_schema.routines
WHERE routine_schema = 'tenant_admin'
  AND routine_name IN (
    'fn_has_permission', 'fn_reset_failed_login_attempts', 'fn_log_admin_action',
    'fn_validate_password_strength', 'fn_generate_security_report', 'fn_set_default_admin_user'
  )
ORDER BY routine_name, routine_type;

-- Verify enums created
SELECT t.typname AS enum_name, e.enumlabel AS enum_value
FROM pg_type t
JOIN pg_enum e ON t.oid = e.enumtypid
JOIN pg_namespace n ON t.typnamespace = n.oid
WHERE n.nspname = 'tenant_admin'
ORDER BY t.typname, e.enumsortorder;

-- Verify default data inserted (only if tenant context exists)
DO $$
DECLARE
  v_tenant_count integer;
BEGIN
  SELECT COUNT(*) INTO v_tenant_count FROM platform.accounts;

  IF v_tenant_count > 0 THEN
    RAISE NOTICE 'Tenant data inserted for % tenants', v_tenant_count;
  ELSE
    RAISE NOTICE 'No tenant context found, skipping default data insertion';
  END IF;
END $$;

-- Test permission checking function (may return NULL without proper auth context)
SELECT tenant_admin.fn_has_permission('users.view') as can_view_users;
SELECT tenant_admin.fn_has_permission('users.delete') as can_delete_users;