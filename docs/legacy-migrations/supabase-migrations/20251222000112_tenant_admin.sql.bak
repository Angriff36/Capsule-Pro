-- MIGRATION: 20251222000112_tenant_admin.sql
-- Admin module: admin_users, admin_roles, admin_permissions, admin_audit_trail
-- All tables follow Schema Contract v2 with composite PK (tenant_id, id)

-- Create schema if not exists
CREATE SCHEMA IF NOT EXISTS tenant_admin AUTHORIZATION postgres;

-- ============================================
-- TENANT_ADMIN.ADMIN_ROLES
-- ============================================

CREATE TABLE tenant_admin.admin_roles (
  tenant_id uuid NOT NULL REFERENCES platform.accounts(id) ON DELETE RESTRICT,
  id uuid DEFAULT gen_random_uuid(),
  role_name text NOT NULL,
  description text,
  permissions jsonb DEFAULT '[]'::jsonb,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  deleted_at timestamptz NULL,
  PRIMARY KEY (tenant_id, id),
  CHECK (role_name IN ('super_admin', 'tenant_admin', 'finance_manager', 'operations_manager', 'staff_manager', 'read_only')),
  CHECK (length(trim(role_name)) <= 50),
  CHECK (description IS NULL OR length(trim(description)) <= 1000),
  CHECK (jsonb_typeof(permissions) = 'array')
);

-- Indexes
CREATE INDEX admin_roles_tenant_name_idx
  ON tenant_admin.admin_roles(tenant_id, role_name) WHERE deleted_at IS NULL;

-- Partial unique index after table creation
CREATE UNIQUE INDEX admin_roles_tenant_name_active_idx
  ON tenant_admin.admin_roles(tenant_id, role_name)
  WHERE deleted_at IS NULL;

-- Triggers
CREATE TRIGGER admin_roles_update_timestamp
  BEFORE UPDATE ON tenant_admin.admin_roles
  FOR EACH ROW EXECUTE FUNCTION core.fn_update_timestamp();

CREATE TRIGGER admin_roles_prevent_tenant_mutation
  BEFORE UPDATE ON tenant_admin.admin_roles
  FOR EACH ROW EXECUTE FUNCTION core.fn_prevent_tenant_mutation();

CREATE TRIGGER admin_roles_audit_trigger
  AFTER INSERT OR UPDATE OR DELETE ON tenant_admin.admin_roles
  FOR EACH ROW EXECUTE FUNCTION core.fn_audit_trigger();

-- RLS Policies
ALTER TABLE tenant_admin.admin_roles ENABLE ROW LEVEL SECURITY;
ALTER TABLE tenant_admin.admin_roles FORCE ROW LEVEL SECURITY;

CREATE POLICY admin_roles_select ON tenant_admin.admin_roles
  FOR SELECT USING (
    tenant_id = (auth.jwt() ->> 'tenant_id')::uuid
    AND deleted_at IS NULL
  );

CREATE POLICY admin_roles_insert ON tenant_admin.admin_roles
  FOR INSERT WITH CHECK (
    tenant_id = (auth.jwt() ->> 'tenant_id')::uuid
    AND tenant_id IS NOT NULL
  );

CREATE POLICY admin_roles_update ON tenant_admin.admin_roles
  FOR UPDATE USING (
    tenant_id = (auth.jwt() ->> 'tenant_id')::uuid
    AND deleted_at IS NULL
  ) WITH CHECK (
    tenant_id = (auth.jwt() ->> 'tenant_id')::uuid
  );

CREATE POLICY admin_roles_delete ON tenant_admin.admin_roles
  FOR DELETE USING (false);

CREATE POLICY admin_roles_service ON tenant_admin.admin_roles
  FOR ALL TO service_role USING (true) WITH CHECK (true);


-- ============================================
-- TENANT_ADMIN.ADMIN_PERMISSIONS
-- ============================================

CREATE TABLE tenant_admin.admin_permissions (
  tenant_id uuid NOT NULL REFERENCES platform.accounts(id) ON DELETE RESTRICT,
  id uuid DEFAULT gen_random_uuid(),
  permission_name text NOT NULL,
  resource text NOT NULL,
  action text NOT NULL,
  description text,
  deleted_at timestamptz NULL,
  PRIMARY KEY (tenant_id, id),
  UNIQUE (tenant_id, id),
  -- Permission name must be unique within tenant
  UNIQUE (tenant_id, permission_name),
  -- Resource and action combinations must be unique within tenant
  UNIQUE (tenant_id, resource, action),
  CHECK (permission_name IN (
    'users.view', 'users.create', 'users.update', 'users.delete',
    'roles.view', 'roles.create', 'roles.update', 'roles.delete',
    'permissions.view', 'permissions.create', 'permissions.update', 'permissions.delete',
    'tenants.view', 'tenants.create', 'tenants.update', 'tenants.delete',
    'reports.view', 'reports.create', 'reports.update', 'reports.delete',
    'settings.view', 'settings.create', 'settings.update', 'settings.delete'
  )),
  CHECK (length(trim(permission_name)) <= 100),
  CHECK (resource IN ('users', 'roles', 'permissions', 'tenants', 'reports', 'settings')),
  CHECK (action IN ('view', 'create', 'update', 'delete')),
  CHECK (length(trim(resource)) <= 50),
  CHECK (length(trim(action)) <= 50),
  CHECK (description IS NULL OR length(trim(description)) <= 500)
);

-- Indexes
CREATE INDEX admin_permissions_tenant_name_idx
  ON tenant_admin.admin_permissions(tenant_id, permission_name) WHERE deleted_at IS NULL;

CREATE INDEX admin_permissions_tenant_resource_action_idx
  ON tenant_admin.admin_permissions(tenant_id, resource, action) WHERE deleted_at IS NULL;

CREATE INDEX admin_permissions_tenant_resource_idx
  ON tenant_admin.admin_permissions(tenant_id, resource) WHERE deleted_at IS NULL;

CREATE INDEX admin_permissions_tenant_action_idx
  ON tenant_admin.admin_permissions(tenant_id, action) WHERE deleted_at IS NULL;

-- Partial unique indexes after table creation
CREATE UNIQUE INDEX admin_permissions_tenant_name_active_idx
  ON tenant_admin.admin_permissions(tenant_id, permission_name)
  WHERE deleted_at IS NULL;

CREATE UNIQUE INDEX admin_permissions_tenant_resource_action_active_idx
  ON tenant_admin.admin_permissions(tenant_id, resource, action)
  WHERE deleted_at IS NULL;

-- Triggers
CREATE TRIGGER admin_permissions_update_timestamp
  BEFORE UPDATE ON tenant_admin.admin_permissions
  FOR EACH ROW EXECUTE FUNCTION core.fn_update_timestamp();

CREATE TRIGGER admin_permissions_prevent_tenant_mutation
  BEFORE UPDATE ON tenant_admin.admin_permissions
  FOR EACH ROW EXECUTE FUNCTION core.fn_prevent_tenant_mutation();

CREATE TRIGGER admin_permissions_audit_trigger
  AFTER INSERT OR UPDATE OR DELETE ON tenant_admin.admin_permissions
  FOR EACH ROW EXECUTE FUNCTION core.fn_audit_trigger();

-- RLS Policies
ALTER TABLE tenant_admin.admin_permissions ENABLE ROW LEVEL SECURITY;
ALTER TABLE tenant_admin.admin_permissions FORCE ROW LEVEL SECURITY;

CREATE POLICY admin_permissions_select ON tenant_admin.admin_permissions
  FOR SELECT USING (
    tenant_id = (auth.jwt() ->> 'tenant_id')::uuid
    AND deleted_at IS NULL
  );

CREATE POLICY admin_permissions_insert ON tenant_admin.admin_permissions
  FOR INSERT WITH CHECK (
    tenant_id = (auth.jwt() ->> 'tenant_id')::uuid
    AND tenant_id IS NOT NULL
  );

CREATE POLICY admin_permissions_update ON tenant_admin.admin_permissions
  FOR UPDATE USING (
    tenant_id = (auth.jwt() ->> 'tenant_id')::uuid
    AND deleted_at IS NULL
  ) WITH CHECK (
    tenant_id = (auth.jwt() ->> 'tenant_id')::uuid
  );

CREATE POLICY admin_permissions_delete ON tenant_admin.admin_permissions
  FOR DELETE USING (false);

CREATE POLICY admin_permissions_service ON tenant_admin.admin_permissions
  FOR ALL TO service_role USING (true) WITH CHECK (true);


-- ============================================
-- TENANT_ADMIN.ADMIN_USERS
-- ============================================

CREATE TABLE tenant_admin.admin_users (
  tenant_id uuid NOT NULL REFERENCES platform.accounts(id) ON DELETE RESTRICT,
  id uuid DEFAULT gen_random_uuid(),
  auth_user_id uuid NOT NULL,
  role uuid NOT NULL,
  is_active boolean NOT NULL DEFAULT true,
  last_login timestamptz,
  last_failed_login timestamptz,
  failed_login_attempts smallint DEFAULT 0,
  locked_until timestamptz,
  two_factor_enabled boolean NOT NULL DEFAULT false,
  two_factor_secret text,
  login_ip text,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  deleted_at timestamptz NULL,
  PRIMARY KEY (tenant_id, id),
  UNIQUE (tenant_id, id),
  -- Same-table FK to admin_roles
  FOREIGN KEY (tenant_id, role)
    REFERENCES tenant_admin.admin_roles(tenant_id, id)
    ON DELETE RESTRICT,
  -- Auth user ID must be unique per tenant
  UNIQUE (tenant_id, auth_user_id),
  -- Email format validation for auth_user_id references
  CHECK (
    -- This is a placeholder constraint - actual validation depends on auth.users structure
    -- In practice, auth_user_id should reference the auth.users.id column
    auth_user_id IS NOT NULL
  ),
  CHECK (is_active IN (true, false)),
  CHECK (last_login IS NULL OR last_login < now()),
  CHECK (last_failed_login IS NULL OR last_failed_login < now()),
  CHECK (failed_login_attempts >= 0 AND failed_login_attempts <= 10),
  CHECK (locked_until IS NULL OR locked_until > now()),
  CHECK (two_factor_enabled IN (true, false)),
  CHECK (two_factor_secret IS NULL OR length(trim(two_factor_secret)) <= 100),
  CHECK (login_ip IS NULL OR login_ip ~* '^([0-9]{1,3}\.){3}[0-9]{1,3}$' OR login_ip ~* '^([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$')
);

-- Indexes
CREATE INDEX admin_users_tenant_auth_user_idx
  ON tenant_admin.admin_users(tenant_id, auth_user_id) WHERE deleted_at IS NULL;

CREATE INDEX admin_users_tenant_role_idx
  ON tenant_admin.admin_users(tenant_id, role) WHERE deleted_at IS NULL;

CREATE INDEX admin_users_tenant_active_idx
  ON tenant_admin.admin_users(tenant_id, is_active) WHERE deleted_at IS NULL;

CREATE INDEX admin_users_tenant_last_login_idx
  ON tenant_admin.admin_users(tenant_id, last_login DESC) WHERE deleted_at IS NULL AND last_login IS NOT NULL;

CREATE INDEX admin_users_tenant_locked_idx
  ON tenant_admin.admin_users(tenant_id, locked_until)
  WHERE deleted_at IS NULL AND locked_until IS NOT NULL;

CREATE INDEX admin_users_auth_user_idx
  ON tenant_admin.admin_users(auth_user_id) WHERE auth_user_id IS NOT NULL;


-- Triggers
CREATE TRIGGER admin_users_update_timestamp
  BEFORE UPDATE ON tenant_admin.admin_users
  FOR EACH ROW EXECUTE FUNCTION core.fn_update_timestamp();

CREATE TRIGGER admin_users_prevent_tenant_mutation
  BEFORE UPDATE ON tenant_admin.admin_users
  FOR EACH ROW EXECUTE FUNCTION core.fn_prevent_tenant_mutation();

CREATE TRIGGER admin_users_audit_trigger
  AFTER INSERT OR UPDATE OR DELETE ON tenant_admin.admin_users
  FOR EACH ROW EXECUTE FUNCTION core.fn_audit_trigger();

-- RLS Policies
ALTER TABLE tenant_admin.admin_users ENABLE ROW LEVEL SECURITY;
ALTER TABLE tenant_admin.admin_users FORCE ROW LEVEL SECURITY;

CREATE POLICY admin_users_select ON tenant_admin.admin_users
  FOR SELECT USING (
    tenant_id = (auth.jwt() ->> 'tenant_id')::uuid
    AND deleted_at IS NULL
  );

CREATE POLICY admin_users_insert ON tenant_admin.admin_users
  FOR INSERT WITH CHECK (
    tenant_id = (auth.jwt() ->> 'tenant_id')::uuid
    AND tenant_id IS NOT NULL
  );

CREATE POLICY admin_users_update ON tenant_admin.admin_users
  FOR UPDATE USING (
    tenant_id = (auth.jwt() ->> 'tenant_id')::uuid
    AND deleted_at IS NULL
  ) WITH CHECK (
    tenant_id = (auth.jwt() ->> 'tenant_id')::uuid
  );

CREATE POLICY admin_users_delete ON tenant_admin.admin_users
  FOR DELETE USING (false);

CREATE POLICY admin_users_service ON tenant_admin.admin_users
  FOR ALL TO service_role USING (true) WITH CHECK (true);


-- ============================================
-- TENANT_ADMIN.ADMIN_AUDIT_TRAIL
-- ============================================

CREATE TABLE tenant_admin.admin_audit_trail (
  tenant_id uuid NOT NULL REFERENCES platform.accounts(id) ON DELETE RESTRICT,
  id uuid DEFAULT gen_random_uuid(),
  admin_user_id uuid NOT NULL,
  action text NOT NULL,
  entity_type text NOT NULL,
  entity_id uuid,
  changes jsonb,
  old_values jsonb,
  new_values jsonb,
  ip_address inet,
  user_agent text,
  session_id uuid,
  created_at timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (tenant_id, id),
  UNIQUE (tenant_id, id),
  -- Same-table FK to admin_users
  FOREIGN KEY (tenant_id, admin_user_id)
    REFERENCES tenant_admin.admin_users(tenant_id, id)
    ON DELETE RESTRICT,
  -- Audit action types
  CHECK (action IN (
    'login', 'logout', 'create', 'update', 'delete', 'view', 'permission_change',
    'role_change', 'account_change', 'security_change'
  )),
  -- Entity types that can be audited
  CHECK (entity_type IN (
    'admin_users', 'admin_roles', 'admin_permissions', 'admin_audit_trail',
    'users', 'roles', 'permissions', 'tenants', 'reports', 'settings'
  )),
  CHECK (length(trim(action)) <= 50),
  CHECK (length(trim(entity_type)) <= 50),
  CHECK (entity_id IS NULL OR (entity_id <> '00000000-0000-0000-0000-000000000000'::uuid)),
  CHECK (changes IS NULL OR jsonb_typeof(changes) IN ('object', 'array', 'string', 'number', 'boolean')),
  CHECK (old_values IS NULL OR jsonb_typeof(old_values) IN ('object', 'array', 'string', 'number', 'boolean')),
  CHECK (new_values IS NULL OR jsonb_typeof(new_values) IN ('object', 'array', 'string', 'number', 'boolean')),
  CHECK (user_agent IS NULL OR length(trim(user_agent)) <= 500),
  CHECK (session_id IS NULL OR (session_id <> '00000000-0000-0000-0000-000000000000'::uuid)),
  CHECK (
    -- For certain actions, entity_id is required
    (action IN ('create', 'update', 'delete') AND entity_id IS NOT NULL) OR
    -- For authentication actions, entity_id can be NULL
    (action IN ('login', 'logout', 'permission_change', 'role_change', 'account_change', 'security_change') AND entity_id IS NULL) OR
    -- For view actions, entity_id can be NULL (e.g., viewing a list)
    (action = 'view' AND entity_id IS NULL)
  ),
  CHECK (
    -- For create/update/delete actions, changes should contain the old_values/new_values
    (action IN ('create', 'update', 'delete') AND (old_values IS NOT NULL OR new_values IS NOT NULL)) OR
    -- For other actions, changes or old_values/new_values can be provided but aren't required
    (NOT action IN ('create', 'update', 'delete'))
  )
);

-- Indexes
CREATE INDEX admin_audit_trail_tenant_admin_user_idx
  ON tenant_admin.admin_audit_trail(tenant_id, admin_user_id);

CREATE INDEX admin_audit_trail_tenant_action_idx
  ON tenant_admin.admin_audit_trail(tenant_id, action);

CREATE INDEX admin_audit_trail_tenant_entity_idx
  ON tenant_admin.admin_audit_trail(tenant_id, entity_type);

CREATE INDEX admin_audit_trail_tenant_entity_id_idx
  ON tenant_admin.admin_audit_trail(tenant_id, entity_type, entity_id)
  WHERE entity_id IS NOT NULL;

CREATE INDEX admin_audit_trail_tenant_created_idx
  ON tenant_admin.admin_audit_trail(tenant_id, created_at DESC);

CREATE INDEX admin_audit_trail_admin_user_idx
  ON tenant_admin.admin_audit_trail(admin_user_id) WHERE admin_user_id IS NOT NULL;

CREATE INDEX admin_audit_trail_action_entity_idx
  ON tenant_admin.admin_audit_trail(action, entity_type)
  WHERE deleted_at IS NULL;

-- Triggers
CREATE TRIGGER admin_audit_trail_update_timestamp
  BEFORE UPDATE ON tenant_admin.admin_audit_trail
  FOR EACH ROW EXECUTE FUNCTION core.fn_update_timestamp();

CREATE TRIGGER admin_audit_trail_prevent_tenant_mutation
  BEFORE UPDATE ON tenant_admin.admin_audit_trail
  FOR EACH ROW EXECUTE FUNCTION core.fn_prevent_tenant_mutation();

CREATE TRIGGER admin_audit_trail_audit_trigger
  AFTER INSERT OR UPDATE OR DELETE ON tenant_admin.admin_audit_trail
  FOR EACH ROW EXECUTE FUNCTION core.fn_audit_trigger();

-- RLS Policies
ALTER TABLE tenant_admin.admin_audit_trail ENABLE ROW LEVEL SECURITY;
ALTER TABLE tenant_admin.admin_audit_trail FORCE ROW LEVEL SECURITY;

CREATE POLICY admin_audit_trail_select ON tenant_admin.admin_audit_trail
  FOR SELECT USING (
    tenant_id = (auth.jwt() ->> 'tenant_id')::uuid
    AND deleted_at IS NULL
  );

CREATE POLICY admin_audit_trail_insert ON tenant_admin.admin_audit_trail
  FOR INSERT WITH CHECK (
    tenant_id = (auth.jwt() ->> 'tenant_id')::uuid
    AND tenant_id IS NOT NULL
  );

CREATE POLICY admin_audit_trail_update ON tenant_admin.admin_audit_trail
  FOR UPDATE USING (
    tenant_id = (auth.jwt() ->> 'tenant_id')::uuid
    AND deleted_at IS NULL
  ) WITH CHECK (
    tenant_id = (auth.jwt() ->> 'tenant_id')::uuid
  );

CREATE POLICY admin_audit_trail_delete ON tenant_admin.admin_audit_trail
  FOR DELETE USING (false);

CREATE POLICY admin_audit_trail_service ON tenant_admin.admin_audit_trail
  FOR ALL TO service_role USING (true) WITH CHECK (true);


-- ============================================
-- ADMIN UTILITY FUNCTIONS
-- ============================================

-- Function to check if user has a specific permission
CREATE FUNCTION tenant_admin.fn_has_permission(p_permission_name text)
RETURNS boolean AS $$
DECLARE
  v_user_id uuid;
  v_role_name text;
  v_permissions jsonb;
  v_permission_exists boolean;
BEGIN
  -- Get current user's ID
  v_user_id := auth.uid();

  -- Get user's role from admin_users table
  SELECT role_name, permissions
  INTO v_role_name, v_permissions
  FROM tenant_admin.admin_users au
  JOIN tenant_admin.admin_roles ar ON au.role = ar.id
  WHERE au.tenant_id = (auth.jwt() ->> 'tenant_id')::uuid
    AND au.auth_user_id = v_user_id
    AND au.is_active = true
    AND au.deleted_at IS NULL
    AND ar.deleted_at IS NULL
    LIMIT 1;

  -- If user has super_admin role, they have all permissions
  IF v_role_name = 'super_admin' THEN
    RETURN true;
  END IF;

  -- Check if permission exists in role's permissions
  SELECT EXISTS(
    SELECT 1
    FROM jsonb_array_elements(v_permissions) AS perm
    WHERE perm->>'name' = p_permission_name
  ) INTO v_permission_exists;

  RETURN v_permission_exists;
END;
$$ LANGUAGE plpgsql
SET search_path = '';

-- Function to reset failed login attempts
CREATE FUNCTION tenant_admin.fn_reset_failed_login_attempts()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.failed_login_attempts > 0 THEN
    NEW.failed_login_attempts := 0;
    NEW.locked_until := NULL;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql
SET search_path = '';

-- Function to log admin actions
CREATE FUNCTION tenant_admin.fn_log_admin_action(
  p_action text,
  p_entity_type text,
  p_entity_id uuid DEFAULT NULL,
  p_changes jsonb DEFAULT NULL,
  p_old_values jsonb DEFAULT NULL,
  p_new_values jsonb DEFAULT NULL
)
RETURNS void AS $$
DECLARE
  v_admin_user_id uuid;
BEGIN
  -- Get current admin user's ID
  SELECT id INTO v_admin_user_id
  FROM tenant_admin.admin_users
  WHERE tenant_id = (auth.jwt() ->> 'tenant_id')::uuid
    AND auth_user_id = auth.uid()
    AND is_active = true
    AND deleted_at IS NULL
    LIMIT 1;

  -- Insert audit record if admin user exists
  IF v_admin_user_id IS NOT NULL THEN
    INSERT INTO tenant_admin.admin_audit_trail (
      tenant_id,
      admin_user_id,
      action,
      entity_type,
      entity_id,
      changes,
      old_values,
      new_values,
      ip_address,
      user_agent,
      session_id
    ) VALUES (
      (auth.jwt() ->> 'tenant_id')::uuid,
      v_admin_user_id,
      p_action,
      p_entity_type,
      p_entity_id,
      p_changes,
      p_old_values,
      p_new_values,
      inet_client_addr(),
      http_user_agent(),
      current_setting('app.session_id', true)::uuid
    );
  END IF;
END;
$$ LANGUAGE plpgsql
SET search_path = '';

-- Function to validate password strength
CREATE FUNCTION tenant_admin.fn_validate_password_strength(p_password text)
RETURNS table(
  is_valid boolean,
  error_message text
) AS $$
DECLARE
  v_length smallint;
  v_has_upper boolean;
  v_has_lower boolean;
  v_has_number boolean;
  v_has_special boolean;
BEGIN
  -- Initialize default values
  is_valid := true;
  error_message := NULL;

  -- Check password length
  v_length := length(p_password);
  IF v_length < 8 THEN
    is_valid := false;
    error_message := 'Password must be at least 8 characters long';
    RETURN NEXT;
    RETURN;
  END IF;

  -- Check for uppercase letter
  v_has_upper := p_password ~ '[A-Z]';
  IF NOT v_has_upper THEN
    is_valid := false;
    error_message := 'Password must contain at least one uppercase letter';
    RETURN NEXT;
    RETURN;
  END IF;

  -- Check for lowercase letter
  v_has_lower := p_password ~ '[a-z]';
  IF NOT v_has_lower THEN
    is_valid := false;
    error_message := 'Password must contain at least one lowercase letter';
    RETURN NEXT;
    RETURN;
  END IF;

  -- Check for number
  v_has_number := p_password ~ '[0-9]';
  IF NOT v_has_number THEN
    is_valid := false;
    error_message := 'Password must contain at least one number';
    RETURN NEXT;
    RETURN;
  END IF;

  -- Check for special character
  v_has_special := p_password ~ '[^A-Za-z0-9]';
  IF NOT v_has_special THEN
    is_valid := false;
    error_message := 'Password must contain at least one special character';
    RETURN NEXT;
    RETURN;
  END IF;

  RETURN NEXT;
END;
$$ LANGUAGE plpgsql
SET search_path = '';

-- Function to generate admin user security report
CREATE FUNCTION tenant_admin.fn_generate_security_report()
RETURNS TABLE(
  total_users integer,
  active_users integer,
  locked_users integer,
  users_with_2fa integer,
  last_login_stats json
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    COUNT(*)::integer as total_users,
    COUNT(CASE WHEN is_active = true THEN 1 END)::integer as active_users,
    COUNT(CASE WHEN locked_until IS NOT NULL AND locked_until > now() THEN 1 END)::integer as locked_users,
    COUNT(CASE WHEN two_factor_enabled = true THEN 1 END)::integer as users_with_2fa,
    jsonb_build_object(
      'most_recent_login', COALESCE(MAX(last_login), 'Never'),
      'oldest_login', COALESCE(MIN(last_login), 'Never'),
      'average_days_since_login',
        CASE
          WHEN COUNT(*) = 0 THEN NULL
          ELSE AVG(EXTRACT(DAY FROM (now() - COALESCE(last_login, now()))))::integer
        END
    ) as last_login_stats
  FROM tenant_admin.admin_users
  WHERE tenant_id = (auth.jwt() ->> 'tenant_id')::uuid
    AND deleted_at IS NULL;
END;
$$ LANGUAGE plpgsql
SET search_path = '';


-- ============================================
-- ADMIN ENUMS
-- ============================================

-- Admin user actions enum
CREATE TYPE tenant_admin.admin_action AS ENUM (
  'login', 'logout', 'create', 'update', 'delete', 'view', 'permission_change',
  'role_change', 'account_change', 'security_change'
);

-- Admin entity types enum
CREATE TYPE tenant_admin.admin_entity_type AS ENUM (
  'admin_users', 'admin_roles', 'admin_permissions', 'admin_audit_trail',
  'users', 'roles', 'permissions', 'tenants', 'reports', 'settings'
);

-- Admin roles enum
CREATE TYPE tenant_admin.admin_role AS ENUM (
  'super_admin', 'tenant_admin', 'finance_manager', 'operations_manager',
  'staff_manager', 'read_only'
);

-- Trigger to auto-set admin user on insert (requires auth trigger setup)
CREATE TRIGGER admin_users_set_admin_user
  BEFORE INSERT ON tenant_admin.admin_users
  FOR EACH ROW
  WHEN (NEW.auth_user_id IS NULL)
  EXECUTE FUNCTION tenant_admin.fn_set_default_admin_user();

-- Function to set default admin user
CREATE FUNCTION tenant_admin.fn_set_default_admin_user()
RETURNS TRIGGER AS $$
BEGIN
  NEW.auth_user_id := auth.uid();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql
SET search_path = '';


-- ============================================
-- DEFAULT ADMIN ROLE AND PERMISSIONS
-- ============================================

-- Insert default roles (only if they don't exist)
INSERT INTO tenant_admin.admin_roles (tenant_id, role_name, description, permissions)
SELECT
  (auth.jwt() ->> 'tenant_id')::uuid,
  role_name,
  description,
  permissions
FROM (VALUES
  ('super_admin', 'Super Administrator', 'Full system access with all permissions',
   '[{"name": "users.view"}, {"name": "users.create"}, {"name": "users.update"}, {"name": "users.delete"},
    {"name": "roles.view"}, {"name": "roles.create"}, {"name": "roles.update"}, {"name": "roles.delete"},
    {"name": "permissions.view"}, {"name": "permissions.create"}, {"name": "permissions.update"}, {"name": "permissions.delete"},
    {"name": "tenants.view"}, {"name": "tenants.create"}, {"name": "tenants.update"}, {"name": "tenants.delete"},
    {"name": "reports.view"}, {"name": "reports.create"}, {"name": "reports.update"}, {"name": "reports.delete"},
    {"name": "settings.view"}, {"name": "settings.create"}, {"name": "settings.update"}, {"name": "settings.delete"}]'),
  ('tenant_admin', 'Tenant Administrator', 'Full access to tenant admin functions',
   '[{"name": "users.view"}, {"name": "users.create"}, {"name": "users.update"}, {"name": "users.delete"},
    {"name": "roles.view"}, {"name": "roles.create"}, {"name": "roles.update"}, {"name": "roles.delete"},
    {"name": "permissions.view"}, {"name": "permissions.create"}, {"name": "permissions.update"}, {"name": "permissions.delete"},
    {"name": "reports.view"}, {"name": "reports.create"}, {"name": "reports.update"}, {"name": "reports.delete"},
    {"name": "settings.view"}, {"name": "settings.create"}, {"name": "settings.update"}]'),
  ('finance_manager', 'Finance Manager', 'Financial operations and reporting',
   '[{"name": "users.view"}, {"name": "users.create"}, {"name": "users.update"},
    {"name": "reports.view"}, {"name": "reports.create"}, {"name": "reports.update"},
    {"name": "settings.view"}, {"name": "settings.update"}]'),
  ('operations_manager', 'Operations Manager', 'Daily operations management',
   '[{"name": "users.view"}, {"name": "users.create"}, {"name": "users.update"},
    {"name": "reports.view"}, {"name": "settings.view"}]'),
  ('staff_manager', 'Staff Manager', 'Staff management and scheduling',
   '[{"name": "users.view"}, {"name": "users.create"}, {"name": "users.update"},
    {"name": "reports.view"}]'),
  ('read_only', 'Read Only', 'View-only access to all modules',
   '[{"name": "users.view"}, {"name": "roles.view"}, {"name": "permissions.view"},
    {"name": "tenants.view"}, {"name": "reports.view"}, {"name": "settings.view"}]')
) AS t(role_name, description, permissions)
WHERE NOT EXISTS (
  SELECT 1 FROM tenant_admin.admin_roles
  WHERE tenant_id = (auth.jwt() ->> 'tenant_id')::uuid
    AND role_name = t.role_name
    AND deleted_at IS NULL
);

-- Insert default permissions (only if they don't exist)
-- Insert default permissions for current tenant or placeholder tenant
INSERT INTO tenant_admin.admin_permissions (tenant_id, permission_name, resource, action, description)
SELECT
  COALESCE(((auth.jwt() ->> 'tenant_id')::uuid), '00000000-0000-0000-0000-000000000000'::uuid),
  permission_name,
  resource,
  action,
  description
FROM (VALUES
  ('users.view', 'users', 'view', 'View user accounts and profiles'),
  ('users.create', 'users', 'create', 'Create new user accounts'),
  ('users.update', 'users', 'update', 'Update existing user accounts'),
  ('users.delete', 'users', 'delete', 'Delete user accounts'),
  ('roles.view', 'roles', 'view', 'View admin roles'),
  ('roles.create', 'roles', 'create', 'Create new admin roles'),
  ('roles.update', 'roles', 'update', 'Update existing admin roles'),
  ('roles.delete', 'roles', 'delete', 'Delete admin roles'),
  ('permissions.view', 'permissions', 'view', 'View permissions'),
  ('permissions.create', 'permissions', 'create', 'Create new permissions'),
  ('permissions.update', 'permissions', 'update', 'Update existing permissions'),
  ('permissions.delete', 'permissions', 'delete', 'Delete permissions'),
  ('tenants.view', 'tenants', 'view', 'View tenant information'),
  ('tenants.create', 'tenants', 'create', 'Create new tenants'),
  ('tenants.update', 'tenants', 'update', 'Update tenant information'),
  ('tenants.delete', 'tenants', 'delete', 'Delete tenants'),
  ('reports.view', 'reports', 'view', 'View system reports'),
  ('reports.create', 'reports', 'create', 'Create new reports'),
  ('reports.update', 'reports', 'update', 'Update existing reports'),
  ('reports.delete', 'reports', 'delete', 'Delete reports'),
  ('settings.view', 'settings', 'view', 'View system settings'),
  ('settings.create', 'settings', 'create', 'Create system settings'),
  ('settings.update', 'settings', 'update', 'Update existing settings'),
  ('settings.delete', 'settings', 'delete', 'Delete system settings')
) AS t(permission_name, resource, action, description)
WHERE NOT EXISTS (
  SELECT 1 FROM tenant_admin.admin_permissions
  WHERE tenant_id = COALESCE(((auth.jwt() ->> 'tenant_id')::uuid), '00000000-0000-0000-0000-000000000000'::uuid)
    AND permission_name = t.permission_name
    AND deleted_at IS NULL
);


-- ============================================
-- VERIFICATION
-- ============================================

-- Verify tables created
SELECT schemaname, tablename
FROM pg_tables
WHERE schemaname = 'tenant_admin'
ORDER BY tablename;

-- Verify indexes created
SELECT schemaname, tablename, indexname
FROM pg_indexes
WHERE schemaname = 'tenant_admin'
ORDER BY tablename, indexname;

-- Verify RLS enabled
SELECT schemaname, tablename, rowsecurity
FROM pg_tables
WHERE schemaname = 'tenant_admin'
ORDER BY tablename;

-- Verify functions created
SELECT routine_name, routine_type
FROM information_schema.routines
WHERE routine_schema = 'tenant_admin'
  AND routine_name IN (
    'fn_has_permission', 'fn_reset_failed_login_attempts', 'fn_log_admin_action',
    'fn_validate_password_strength', 'fn_generate_security_report', 'fn_set_default_admin_user'
  )
ORDER BY routine_name, routine_type;

-- Verify enums created
SELECT t.typname AS enum_name, e.enumlabel AS enum_value
FROM pg_type t
JOIN pg_enum e ON t.oid = e.enumtypid
JOIN pg_namespace n ON t.typnamespace = n.oid
WHERE n.nspname = 'tenant_admin'
ORDER BY t.typname, e.enumsortorder;

-- Verify default data inserted (using placeholder tenant if no context)
SELECT 'admin_roles' as table_name, COUNT(*) as record_count
FROM tenant_admin.admin_roles
WHERE tenant_id = COALESCE(((auth.jwt() ->> 'tenant_id')::uuid), '00000000-0000-0000-0000-000000000000'::uuid) AND deleted_at IS NULL

UNION ALL

SELECT 'admin_permissions' as table_name, COUNT(*) as record_count
FROM tenant_admin.admin_permissions
WHERE tenant_id = COALESCE(((auth.jwt() ->> 'tenant_id')::uuid), '00000000-0000-0000-0000-000000000000'::uuid) AND deleted_at IS NULL;

-- Test permission checking function (may return NULL without proper auth context)
SELECT tenant_admin.fn_has_permission('users.view') as can_view_users;
SELECT tenant_admin.fn_has_permission('users.delete') as can_delete_users;