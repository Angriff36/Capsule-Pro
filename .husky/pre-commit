#!/bin/sh
# Exit on any error
set -e

# Check if there are any staged files
if [ -z "$(git diff --cached --name-only)" ]; then
  echo "No staged files to format"
  exit 0
fi

# Store the hash of staged changes to detect modifications (cross-platform)
STAGED_HASH=$(git diff --cached | git hash-object --stdin)

# Save list of staged files (handling all file states)
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACMR)
PARTIALLY_STAGED=$(git diff --name-only)

# Stash unstaged changes to preserve working directory
# --keep-index keeps staged changes in working tree
git stash push --quiet --keep-index --message "pre-commit-stash" || true
STASHED=$?

# Run formatter/linter only on staged files
# Use --stdin-file-path piping is not available; instead chunk files to avoid
# Windows command-line length limits (8191 chars) when many files are staged.
FORMAT_EXIT_CODE=0
if [ -n "$STAGED_FILES" ]; then
  # Process files in chunks of 50 to stay well under Windows arg-length limits
  chunk=()
  count=0
  while IFS= read -r file; do
    chunk+=("$file")
    count=$((count + 1))
    if [ $count -eq 50 ]; then
      pnpm dlx biome check --write --files-ignore-unknown=true "${chunk[@]}" || FORMAT_EXIT_CODE=$?
      chunk=()
      count=0
    fi
  done <<< "$STAGED_FILES"
  # Process remaining files
  if [ ${#chunk[@]} -gt 0 ]; then
    pnpm dlx biome check --write --files-ignore-unknown=true "${chunk[@]}" || FORMAT_EXIT_CODE=$?
  fi
fi

# Restore working directory state
if [ $STASHED -eq 0 ]; then
  # Re-stage the formatted files (use -f since some may be in gitignored paths but were already tracked)
  if [ -n "$STAGED_FILES" ]; then
    echo "$STAGED_FILES" | while IFS= read -r file; do
      if [ -f "$file" ]; then
        git add -f "$file"
      fi
    done
  fi

  # Restore unstaged changes
  git stash pop --quiet || true

  # Restore partial staging if files were partially staged
  if [ -n "$PARTIALLY_STAGED" ]; then
    for file in $PARTIALLY_STAGED; do
      if [ -f "$file" ] && echo "$STAGED_FILES" | grep -q "^$file$"; then
        # File was partially staged - need to unstage the unstaged parts
        git restore --staged "$file" 2>/dev/null || true
        git add -p "$file" < /dev/null 2>/dev/null || git add "$file"
      fi
    done
  fi
else
  # No stash was created, just re-add the formatted files
  if [ -n "$STAGED_FILES" ]; then
    echo "$STAGED_FILES" | while IFS= read -r file; do
      if [ -f "$file" ]; then
        git add -f "$file"
      fi
    done
  fi
fi

# Check if staged files actually changed (cross-platform, uses git built-in)
NEW_STAGED_HASH=$(git diff --cached | git hash-object --stdin)
if [ "$STAGED_HASH" != "$NEW_STAGED_HASH" ]; then
  echo "âœ¨ Files formatted by Ultracite"
fi

# Block staged non-manifest write route handlers.
ROUTE_GUARD_EXIT=0
if [ $FORMAT_EXIT_CODE -eq 0 ]; then
  pnpm exec node scripts/check-staged-write-routes.mjs || ROUTE_GUARD_EXIT=$?
fi
if [ $ROUTE_GUARD_EXIT -ne 0 ]; then
  exit $ROUTE_GUARD_EXIT
fi

exit $FORMAT_EXIT_CODE
