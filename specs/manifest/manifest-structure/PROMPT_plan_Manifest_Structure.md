0a. Study `docs/manifest/*` and `docs/manifest-official/*` with up to 250 parallel Sonnet subagents to learn the application specifications.
0b. Study `docs/Roadmap/IMPLEMENTATION_PLAN.md` (if present) to understand the plan so far.
0c. Study `packages/manifest-sources/*`, `packages/manifest-ir/*`, and `packages/manifest-adapters/*` with up to 250 parallel Sonnet subagents to understand the Manifest integration surface area (sources, IR, adapters, and generated glue).
0d. For reference, the relevant code for this project lives in `apps/api/app/api/*` and `apps/api/lib/*` and the Manifest-related packages under `packages/manifest-*`.

1. Study `docs/Roadmap/IMPLEMENTATION_PLAN.md` (if present; it may be incorrect) and use Task tool with up to 500 parallel subagents (subagent_type='Explore') to study existing source code in `apps/api/app/api/*`, `apps/api/lib/*`, and `packages/manifest-*/*` and compare it against `docs/manifest/*` and `docs/manifest-official/*`. Use Task tool with subagent_type='Opus' or model='opus' to analyze findings, prioritize tasks, and create/update `docs/Roadmap/IMPLEMENTATION_PLAN.md` as a bullet point list sorted in priority of items yet to be implemented. Ultrathink. Consider searching for TODO, minimal implementations, placeholders, skipped/flaky tests, and inconsistent patterns. Additionally, perform a full directory understanding pass and produce a canonical mapping for “where everything belongs” by (a) enumerating all Manifest-related inputs/outputs/consumers and their current locations, (b) detecting conflicts where multiple directories plausibly compete for the same role, and (c) recommending a single correct location for each artifact type with explicit rationale. The mapping must at minimum cover: `packages/manifest-sources` (manifest inputs), `packages/manifest-ir` (compiled IR outputs), `packages/manifest-adapters` (shared reusable glue if justified), generated Next.js route handlers under `apps/api/app/api/*`, runtime bridge code used by those handlers, and app-owned integration wiring under `apps/api/lib/*`. Conflicts to explicitly detect and report include: duplicate domain roots (e.g., domain appears in both `apps/api/app/api/<domain>` and another location), overlapping “adapter vs app-lib” ownership for runtime factories, duplicate or competing store implementations, and any path that causes generated code to import from an unstable or circular location. Study `docs/Roadmap/IMPLEMENTATION_PLAN.md` to determine starting point for research and keep it up to date with items considered complete/incomplete. IMPORTANT: Always use the Task tool for file operations, searches, and analysis, never use Read/Grep directly for exploration work. Existing sections in `IMPLEMENTATION_PLAN.md` are considered stable unless new hard evidence contradicts them.
New findings must be appended under a clearly labeled “Iteration N Findings” section. Rewrites of existing sections require explicit evidence reference.

IMPORTANT: Plan only. Do NOT implement anything. Do NOT assume functionality is missing; confirm with code search first. Treat `packages/manifest-adapters` as the shared library surface only if it is genuinely generic and reusable across multiple domains/apps; otherwise prefer app-owned wiring in `apps/api/lib/*` and domain-local generated helpers under `apps/api/app/api/<domain>`.

ULTIMATE GOAL: We want to deliver a deterministic, production-ready Manifest pipeline layout for Capsule-Pro. That means identifying every source of truth (manifests in `packages/manifest-sources`, IR artifacts in `packages/manifest-ir`, projection outputs under `apps/api/app/api/*`, shared glue in `packages/manifest-adapters` if warranted, and app wiring in `apps/api/lib/*`), detecting all competing/overlapping locations, and resolving them into a single deterministic layout so projections always write to the correct place and consumers always import from the correct place. The output must include: (1) a directory map, (2) a conflict list with exact paths and why each conflict occurs, (3) a canonical “this lives here” table for each artifact type, and (4) repo conventions/guardrails to prevent the conflicts from coming back. If an element is missing, search first to confirm it doesn't exist, then if needed author the specification at `docs/manifest/FILENAME.md`. If you create a new element then document the plan to implement it in `docs/Roadmap/IMPLEMENTATION_PLAN.md` using a subagent.
